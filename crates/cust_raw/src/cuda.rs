/* automatically generated by rust-bindgen 0.58.1 */

pub const CUDA_VERSION: u32 = 11040;
pub const CU_IPC_HANDLE_SIZE: u32 = 64;
pub const CU_MEMHOSTALLOC_PORTABLE: u32 = 1;
pub const CU_MEMHOSTALLOC_DEVICEMAP: u32 = 2;
pub const CU_MEMHOSTALLOC_WRITECOMBINED: u32 = 4;
pub const CU_MEMHOSTREGISTER_PORTABLE: u32 = 1;
pub const CU_MEMHOSTREGISTER_DEVICEMAP: u32 = 2;
pub const CU_MEMHOSTREGISTER_IOMEMORY: u32 = 4;
pub const CU_MEMHOSTREGISTER_READ_ONLY: u32 = 8;
pub const CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL: u32 = 1;
pub const CUDA_EXTERNAL_MEMORY_DEDICATED: u32 = 1;
pub const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC: u32 = 1;
pub const CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC: u32 = 2;
pub const CUDA_NVSCISYNC_ATTR_SIGNAL: u32 = 1;
pub const CUDA_NVSCISYNC_ATTR_WAIT: u32 = 2;
pub const CU_MEM_CREATE_USAGE_TILE_POOL: u32 = 1;
pub const CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_PRE_LAUNCH_SYNC: u32 = 1;
pub const CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_POST_LAUNCH_SYNC: u32 = 2;
pub const CUDA_ARRAY3D_LAYERED: u32 = 1;
pub const CUDA_ARRAY3D_2DARRAY: u32 = 1;
pub const CUDA_ARRAY3D_SURFACE_LDST: u32 = 2;
pub const CUDA_ARRAY3D_CUBEMAP: u32 = 4;
pub const CUDA_ARRAY3D_TEXTURE_GATHER: u32 = 8;
pub const CUDA_ARRAY3D_DEPTH_TEXTURE: u32 = 16;
pub const CUDA_ARRAY3D_COLOR_ATTACHMENT: u32 = 32;
pub const CUDA_ARRAY3D_SPARSE: u32 = 64;
pub const CU_TRSA_OVERRIDE_FORMAT: u32 = 1;
pub const CU_TRSF_READ_AS_INTEGER: u32 = 1;
pub const CU_TRSF_NORMALIZED_COORDINATES: u32 = 2;
pub const CU_TRSF_SRGB: u32 = 16;
pub const CU_TRSF_DISABLE_TRILINEAR_OPTIMIZATION: u32 = 32;
pub const CU_PARAM_TR_DEFAULT: i32 = -1;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct float2 {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_float2() {
    assert_eq!(
        ::std::mem::size_of::<float2>(),
        8usize,
        concat!("Size of: ", stringify!(float2))
    );
    assert_eq!(
        ::std::mem::align_of::<float2>(),
        8usize,
        concat!("Alignment of ", stringify!(float2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<float2>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(float2), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<float2>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(float2), "::", stringify!(y))
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct double2 {
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout_double2() {
    assert_eq!(
        ::std::mem::size_of::<double2>(),
        16usize,
        concat!("Size of: ", stringify!(double2))
    );
    assert_eq!(
        ::std::mem::align_of::<double2>(),
        16usize,
        concat!("Alignment of ", stringify!(double2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<double2>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(double2),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<double2>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(double2),
            "::",
            stringify!(y)
        )
    );
}
pub type cuFloatComplex = float2;
pub type cuDoubleComplex = double2;
pub type cuComplex = cuFloatComplex;
pub type cuuint32_t = ::std::os::raw::c_uint;
pub type cuuint64_t = ::std::os::raw::c_ulonglong;
pub type CUdeviceptr_v2 = ::std::os::raw::c_ulonglong;
pub type CUdeviceptr = CUdeviceptr_v2;
pub type CUdevice_v1 = ::std::os::raw::c_int;
pub type CUdevice = CUdevice_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUctx_st {
    _unused: [u8; 0],
}
pub type CUcontext = *mut CUctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmod_st {
    _unused: [u8; 0],
}
pub type CUmodule = *mut CUmod_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUfunc_st {
    _unused: [u8; 0],
}
pub type CUfunction = *mut CUfunc_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUarray_st {
    _unused: [u8; 0],
}
pub type CUarray = *mut CUarray_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmipmappedArray_st {
    _unused: [u8; 0],
}
pub type CUmipmappedArray = *mut CUmipmappedArray_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUtexref_st {
    _unused: [u8; 0],
}
pub type CUtexref = *mut CUtexref_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUsurfref_st {
    _unused: [u8; 0],
}
pub type CUsurfref = *mut CUsurfref_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUevent_st {
    _unused: [u8; 0],
}
pub type CUevent = *mut CUevent_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUstream_st {
    _unused: [u8; 0],
}
pub type CUstream = *mut CUstream_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphicsResource_st {
    _unused: [u8; 0],
}
pub type CUgraphicsResource = *mut CUgraphicsResource_st;
pub type CUtexObject_v1 = ::std::os::raw::c_ulonglong;
pub type CUtexObject = CUtexObject_v1;
pub type CUsurfObject_v1 = ::std::os::raw::c_ulonglong;
pub type CUsurfObject = CUsurfObject_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUextMemory_st {
    _unused: [u8; 0],
}
pub type CUexternalMemory = *mut CUextMemory_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUextSemaphore_st {
    _unused: [u8; 0],
}
pub type CUexternalSemaphore = *mut CUextSemaphore_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraph_st {
    _unused: [u8; 0],
}
pub type CUgraph = *mut CUgraph_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphNode_st {
    _unused: [u8; 0],
}
pub type CUgraphNode = *mut CUgraphNode_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphExec_st {
    _unused: [u8; 0],
}
pub type CUgraphExec = *mut CUgraphExec_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemPoolHandle_st {
    _unused: [u8; 0],
}
pub type CUmemoryPool = *mut CUmemPoolHandle_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUuserObject_st {
    _unused: [u8; 0],
}
pub type CUuserObject = *mut CUuserObject_st;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUuuid_st {
    pub bytes: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_CUuuid_st() {
    assert_eq!(
        ::std::mem::size_of::<CUuuid_st>(),
        16usize,
        concat!("Size of: ", stringify!(CUuuid_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUuuid_st>(),
        1usize,
        concat!("Alignment of ", stringify!(CUuuid_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUuuid_st>())).bytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUuuid_st),
            "::",
            stringify!(bytes)
        )
    );
}
pub type CUuuid = CUuuid_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUipcEventHandle_st {
    pub reserved: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_CUipcEventHandle_st() {
    assert_eq!(
        ::std::mem::size_of::<CUipcEventHandle_st>(),
        64usize,
        concat!("Size of: ", stringify!(CUipcEventHandle_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUipcEventHandle_st>(),
        1usize,
        concat!("Alignment of ", stringify!(CUipcEventHandle_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUipcEventHandle_st>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUipcEventHandle_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUipcEventHandle_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUipcEventHandle_v1 = CUipcEventHandle_st;
pub type CUipcEventHandle = CUipcEventHandle_v1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUipcMemHandle_st {
    pub reserved: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_CUipcMemHandle_st() {
    assert_eq!(
        ::std::mem::size_of::<CUipcMemHandle_st>(),
        64usize,
        concat!("Size of: ", stringify!(CUipcMemHandle_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUipcMemHandle_st>(),
        1usize,
        concat!("Alignment of ", stringify!(CUipcMemHandle_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUipcMemHandle_st>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUipcMemHandle_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUipcMemHandle_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUipcMemHandle_v1 = CUipcMemHandle_st;
pub type CUipcMemHandle = CUipcMemHandle_v1;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUipcMem_flags_enum {
    CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS = 1,
}
pub use self::CUipcMem_flags_enum as CUipcMem_flags;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUmemAttach_flags_enum {
    CU_MEM_ATTACH_GLOBAL = 1,
    CU_MEM_ATTACH_HOST = 2,
    CU_MEM_ATTACH_SINGLE = 4,
}
pub use self::CUmemAttach_flags_enum as CUmemAttach_flags;
impl CUctx_flags_enum {
    pub const CU_CTX_BLOCKING_SYNC: CUctx_flags_enum = CUctx_flags_enum::CU_CTX_SCHED_BLOCKING_SYNC;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUctx_flags_enum {
    CU_CTX_SCHED_AUTO = 0,
    CU_CTX_SCHED_SPIN = 1,
    CU_CTX_SCHED_YIELD = 2,
    CU_CTX_SCHED_BLOCKING_SYNC = 4,
    CU_CTX_SCHED_MASK = 7,
    CU_CTX_MAP_HOST = 8,
    CU_CTX_LMEM_RESIZE_TO_MAX = 16,
    CU_CTX_FLAGS_MASK = 31,
}
pub use self::CUctx_flags_enum as CUctx_flags;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUstream_flags_enum {
    CU_STREAM_DEFAULT = 0,
    CU_STREAM_NON_BLOCKING = 1,
}
pub use self::CUstream_flags_enum as CUstream_flags;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUevent_flags_enum {
    CU_EVENT_DEFAULT = 0,
    CU_EVENT_BLOCKING_SYNC = 1,
    CU_EVENT_DISABLE_TIMING = 2,
    CU_EVENT_INTERPROCESS = 4,
}
pub use self::CUevent_flags_enum as CUevent_flags;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUevent_record_flags_enum {
    CU_EVENT_RECORD_DEFAULT = 0,
    CU_EVENT_RECORD_EXTERNAL = 1,
}
pub use self::CUevent_record_flags_enum as CUevent_record_flags;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUevent_wait_flags_enum {
    CU_EVENT_WAIT_DEFAULT = 0,
    CU_EVENT_WAIT_EXTERNAL = 1,
}
pub use self::CUevent_wait_flags_enum as CUevent_wait_flags;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUstreamWaitValue_flags_enum {
    CU_STREAM_WAIT_VALUE_GEQ = 0,
    CU_STREAM_WAIT_VALUE_EQ = 1,
    CU_STREAM_WAIT_VALUE_AND = 2,
    CU_STREAM_WAIT_VALUE_NOR = 3,
    CU_STREAM_WAIT_VALUE_FLUSH = 1073741824,
}
pub use self::CUstreamWaitValue_flags_enum as CUstreamWaitValue_flags;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUstreamWriteValue_flags_enum {
    CU_STREAM_WRITE_VALUE_DEFAULT = 0,
    CU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER = 1,
}
pub use self::CUstreamWriteValue_flags_enum as CUstreamWriteValue_flags;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUstreamBatchMemOpType_enum {
    CU_STREAM_MEM_OP_WAIT_VALUE_32 = 1,
    CU_STREAM_MEM_OP_WRITE_VALUE_32 = 2,
    CU_STREAM_MEM_OP_WAIT_VALUE_64 = 4,
    CU_STREAM_MEM_OP_WRITE_VALUE_64 = 5,
    CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES = 3,
}
pub use self::CUstreamBatchMemOpType_enum as CUstreamBatchMemOpType;
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUstreamBatchMemOpParams_union {
    pub operation: CUstreamBatchMemOpType,
    pub waitValue: CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st,
    pub writeValue: CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st,
    pub flushRemoteWrites: CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st,
    pub pad: [cuuint64_t; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st {
    pub operation: CUstreamBatchMemOpType,
    pub address: CUdeviceptr,
    pub __bindgen_anon_1:
        CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
    pub alias: CUdeviceptr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1 {
    pub value: cuuint32_t,
    pub value64: cuuint64_t,
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1(
) {
    assert_eq!(
        ::std::mem::size_of::<
            CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1,
            >()))
            .value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1
            ),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1,
            >()))
            .value64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1
            ),
            "::",
            stringify!(value64)
        )
    );
}
impl Default for CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st() {
    assert_eq!(
        ::std::mem::size_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st>(
            )))
            .operation as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st>(
            )))
            .address as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st>(
            )))
            .flags as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st>(
            )))
            .alias as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st),
            "::",
            stringify!(alias)
        )
    );
}
impl Default for CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st {
    pub operation: CUstreamBatchMemOpType,
    pub address: CUdeviceptr,
    pub __bindgen_anon_1:
        CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
    pub alias: CUdeviceptr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1 {
    pub value: cuuint32_t,
    pub value64: cuuint64_t,
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1(
) {
    assert_eq!(
        ::std::mem::size_of::<
            CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1,
            >()))
            .value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1
            ),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1,
            >()))
            .value64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1
            ),
            "::",
            stringify!(value64)
        )
    );
}
impl Default for CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st() {
    assert_eq!(
        ::std::mem::size_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st>(
            )))
            .operation as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st>(
            )))
            .address as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st>(
            )))
            .flags as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st>(
            )))
            .alias as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st),
            "::",
            stringify!(alias)
        )
    );
}
impl Default for CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st {
    pub operation: CUstreamBatchMemOpType,
    pub flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st() {
    assert_eq!(
        ::std::mem::size_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st>(
        ),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st,
            >()))
            .operation as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st,
            >()))
            .flags as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union() {
    assert_eq!(
        ::std::mem::size_of::<CUstreamBatchMemOpParams_union>(),
        48usize,
        concat!("Size of: ", stringify!(CUstreamBatchMemOpParams_union))
    );
    assert_eq!(
        ::std::mem::align_of::<CUstreamBatchMemOpParams_union>(),
        8usize,
        concat!("Alignment of ", stringify!(CUstreamBatchMemOpParams_union))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union>())).operation as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union>())).waitValue as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union),
            "::",
            stringify!(waitValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union>())).writeValue as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union),
            "::",
            stringify!(writeValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union>())).flushRemoteWrites as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union),
            "::",
            stringify!(flushRemoteWrites)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamBatchMemOpParams_union>())).pad as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union),
            "::",
            stringify!(pad)
        )
    );
}
impl Default for CUstreamBatchMemOpParams_union {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUstreamBatchMemOpParams_v1 = CUstreamBatchMemOpParams_union;
pub type CUstreamBatchMemOpParams = CUstreamBatchMemOpParams_v1;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUoccupancy_flags_enum {
    CU_OCCUPANCY_DEFAULT = 0,
    CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE = 1,
}
pub use self::CUoccupancy_flags_enum as CUoccupancy_flags;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUstreamUpdateCaptureDependencies_flags_enum {
    CU_STREAM_ADD_CAPTURE_DEPENDENCIES = 0,
    CU_STREAM_SET_CAPTURE_DEPENDENCIES = 1,
}
pub use self::CUstreamUpdateCaptureDependencies_flags_enum as CUstreamUpdateCaptureDependencies_flags;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUarray_format_enum {
    CU_AD_FORMAT_UNSIGNED_INT8 = 1,
    CU_AD_FORMAT_UNSIGNED_INT16 = 2,
    CU_AD_FORMAT_UNSIGNED_INT32 = 3,
    CU_AD_FORMAT_SIGNED_INT8 = 8,
    CU_AD_FORMAT_SIGNED_INT16 = 9,
    CU_AD_FORMAT_SIGNED_INT32 = 10,
    CU_AD_FORMAT_HALF = 16,
    CU_AD_FORMAT_FLOAT = 32,
    CU_AD_FORMAT_NV12 = 176,
}
pub use self::CUarray_format_enum as CUarray_format;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUaddress_mode_enum {
    CU_TR_ADDRESS_MODE_WRAP = 0,
    CU_TR_ADDRESS_MODE_CLAMP = 1,
    CU_TR_ADDRESS_MODE_MIRROR = 2,
    CU_TR_ADDRESS_MODE_BORDER = 3,
}
pub use self::CUaddress_mode_enum as CUaddress_mode;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUfilter_mode_enum {
    CU_TR_FILTER_MODE_POINT = 0,
    CU_TR_FILTER_MODE_LINEAR = 1,
}
pub use self::CUfilter_mode_enum as CUfilter_mode;
impl CUdevice_attribute_enum {
    pub const CU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK: CUdevice_attribute_enum =
        CUdevice_attribute_enum::CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK;
}
impl CUdevice_attribute_enum {
    pub const CU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK: CUdevice_attribute_enum =
        CUdevice_attribute_enum::CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK;
}
impl CUdevice_attribute_enum {
    pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH: CUdevice_attribute_enum =
        CUdevice_attribute_enum::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH;
}
impl CUdevice_attribute_enum {
    pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT: CUdevice_attribute_enum =
        CUdevice_attribute_enum::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT;
}
impl CUdevice_attribute_enum {
    pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES: CUdevice_attribute_enum =
        CUdevice_attribute_enum::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS;
}
impl CUdevice_attribute_enum {
    pub const CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED: CUdevice_attribute_enum =
        CUdevice_attribute_enum::CU_DEVICE_ATTRIBUTE_VIRTUAL_ADDRESS_MANAGEMENT_SUPPORTED;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUdevice_attribute_enum {
    CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 1,
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X = 2,
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y = 3,
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z = 4,
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X = 5,
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y = 6,
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z = 7,
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK = 8,
    CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY = 9,
    CU_DEVICE_ATTRIBUTE_WARP_SIZE = 10,
    CU_DEVICE_ATTRIBUTE_MAX_PITCH = 11,
    CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK = 12,
    CU_DEVICE_ATTRIBUTE_CLOCK_RATE = 13,
    CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT = 14,
    CU_DEVICE_ATTRIBUTE_GPU_OVERLAP = 15,
    CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT = 16,
    CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT = 17,
    CU_DEVICE_ATTRIBUTE_INTEGRATED = 18,
    CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY = 19,
    CU_DEVICE_ATTRIBUTE_COMPUTE_MODE = 20,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH = 21,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH = 22,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT = 23,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH = 24,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT = 25,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH = 26,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH = 27,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT = 28,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS = 29,
    CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT = 30,
    CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS = 31,
    CU_DEVICE_ATTRIBUTE_ECC_ENABLED = 32,
    CU_DEVICE_ATTRIBUTE_PCI_BUS_ID = 33,
    CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID = 34,
    CU_DEVICE_ATTRIBUTE_TCC_DRIVER = 35,
    CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE = 36,
    CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH = 37,
    CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE = 38,
    CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR = 39,
    CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT = 40,
    CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING = 41,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH = 42,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS = 43,
    CU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER = 44,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH = 45,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT = 46,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE = 47,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE = 48,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE = 49,
    CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID = 50,
    CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT = 51,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH = 52,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH = 53,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS = 54,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH = 55,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH = 56,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT = 57,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH = 58,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT = 59,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH = 60,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH = 61,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS = 62,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH = 63,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT = 64,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS = 65,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH = 66,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH = 67,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS = 68,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH = 69,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH = 70,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT = 71,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH = 72,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH = 73,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT = 74,
    CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR = 75,
    CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR = 76,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH = 77,
    CU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED = 78,
    CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED = 79,
    CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED = 80,
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR = 81,
    CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR = 82,
    CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY = 83,
    CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD = 84,
    CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID = 85,
    CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED = 86,
    CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO = 87,
    CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS = 88,
    CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS = 89,
    CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED = 90,
    CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM = 91,
    CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_MEM_OPS = 92,
    CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS = 93,
    CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR = 94,
    CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH = 95,
    CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH = 96,
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN = 97,
    CU_DEVICE_ATTRIBUTE_CAN_FLUSH_REMOTE_WRITES = 98,
    CU_DEVICE_ATTRIBUTE_HOST_REGISTER_SUPPORTED = 99,
    CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES = 100,
    CU_DEVICE_ATTRIBUTE_DIRECT_MANAGED_MEM_ACCESS_FROM_HOST = 101,
    CU_DEVICE_ATTRIBUTE_VIRTUAL_ADDRESS_MANAGEMENT_SUPPORTED = 102,
    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR_SUPPORTED = 103,
    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_HANDLE_SUPPORTED = 104,
    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_KMT_HANDLE_SUPPORTED = 105,
    CU_DEVICE_ATTRIBUTE_MAX_BLOCKS_PER_MULTIPROCESSOR = 106,
    CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED = 107,
    CU_DEVICE_ATTRIBUTE_MAX_PERSISTING_L2_CACHE_SIZE = 108,
    CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE = 109,
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WITH_CUDA_VMM_SUPPORTED = 110,
    CU_DEVICE_ATTRIBUTE_RESERVED_SHARED_MEMORY_PER_BLOCK = 111,
    CU_DEVICE_ATTRIBUTE_SPARSE_CUDA_ARRAY_SUPPORTED = 112,
    CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED = 113,
    CU_DEVICE_ATTRIBUTE_TIMELINE_SEMAPHORE_INTEROP_SUPPORTED = 114,
    CU_DEVICE_ATTRIBUTE_MEMORY_POOLS_SUPPORTED = 115,
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_SUPPORTED = 116,
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS = 117,
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING = 118,
    CU_DEVICE_ATTRIBUTE_MEMPOOL_SUPPORTED_HANDLE_TYPES = 119,
    CU_DEVICE_ATTRIBUTE_MAX = 120,
}
pub use self::CUdevice_attribute_enum as CUdevice_attribute;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUdevprop_st {
    pub maxThreadsPerBlock: ::std::os::raw::c_int,
    pub maxThreadsDim: [::std::os::raw::c_int; 3usize],
    pub maxGridSize: [::std::os::raw::c_int; 3usize],
    pub sharedMemPerBlock: ::std::os::raw::c_int,
    pub totalConstantMemory: ::std::os::raw::c_int,
    pub SIMDWidth: ::std::os::raw::c_int,
    pub memPitch: ::std::os::raw::c_int,
    pub regsPerBlock: ::std::os::raw::c_int,
    pub clockRate: ::std::os::raw::c_int,
    pub textureAlign: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CUdevprop_st() {
    assert_eq!(
        ::std::mem::size_of::<CUdevprop_st>(),
        56usize,
        concat!("Size of: ", stringify!(CUdevprop_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUdevprop_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUdevprop_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUdevprop_st>())).maxThreadsPerBlock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(maxThreadsPerBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUdevprop_st>())).maxThreadsDim as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(maxThreadsDim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUdevprop_st>())).maxGridSize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(maxGridSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUdevprop_st>())).sharedMemPerBlock as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(sharedMemPerBlock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUdevprop_st>())).totalConstantMemory as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(totalConstantMemory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUdevprop_st>())).SIMDWidth as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(SIMDWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUdevprop_st>())).memPitch as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(memPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUdevprop_st>())).regsPerBlock as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(regsPerBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUdevprop_st>())).clockRate as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(clockRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUdevprop_st>())).textureAlign as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(textureAlign)
        )
    );
}
pub type CUdevprop_v1 = CUdevprop_st;
pub type CUdevprop = CUdevprop_v1;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUpointer_attribute_enum {
    CU_POINTER_ATTRIBUTE_CONTEXT = 1,
    CU_POINTER_ATTRIBUTE_MEMORY_TYPE = 2,
    CU_POINTER_ATTRIBUTE_DEVICE_POINTER = 3,
    CU_POINTER_ATTRIBUTE_HOST_POINTER = 4,
    CU_POINTER_ATTRIBUTE_P2P_TOKENS = 5,
    CU_POINTER_ATTRIBUTE_SYNC_MEMOPS = 6,
    CU_POINTER_ATTRIBUTE_BUFFER_ID = 7,
    CU_POINTER_ATTRIBUTE_IS_MANAGED = 8,
    CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL = 9,
    CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE = 10,
    CU_POINTER_ATTRIBUTE_RANGE_START_ADDR = 11,
    CU_POINTER_ATTRIBUTE_RANGE_SIZE = 12,
    CU_POINTER_ATTRIBUTE_MAPPED = 13,
    CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES = 14,
    CU_POINTER_ATTRIBUTE_IS_GPU_DIRECT_RDMA_CAPABLE = 15,
    CU_POINTER_ATTRIBUTE_ACCESS_FLAGS = 16,
    CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE = 17,
}
pub use self::CUpointer_attribute_enum as CUpointer_attribute;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUfunction_attribute_enum {
    CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 0,
    CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES = 1,
    CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES = 2,
    CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES = 3,
    CU_FUNC_ATTRIBUTE_NUM_REGS = 4,
    CU_FUNC_ATTRIBUTE_PTX_VERSION = 5,
    CU_FUNC_ATTRIBUTE_BINARY_VERSION = 6,
    CU_FUNC_ATTRIBUTE_CACHE_MODE_CA = 7,
    CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES = 8,
    CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT = 9,
    CU_FUNC_ATTRIBUTE_MAX = 10,
}
pub use self::CUfunction_attribute_enum as CUfunction_attribute;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUfunc_cache_enum {
    CU_FUNC_CACHE_PREFER_NONE = 0,
    CU_FUNC_CACHE_PREFER_SHARED = 1,
    CU_FUNC_CACHE_PREFER_L1 = 2,
    CU_FUNC_CACHE_PREFER_EQUAL = 3,
}
pub use self::CUfunc_cache_enum as CUfunc_cache;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUsharedconfig_enum {
    CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE = 0,
    CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE = 1,
    CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE = 2,
}
pub use self::CUsharedconfig_enum as CUsharedconfig;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUshared_carveout_enum {
    CU_SHAREDMEM_CARVEOUT_DEFAULT = -1,
    CU_SHAREDMEM_CARVEOUT_MAX_SHARED = 100,
    CU_SHAREDMEM_CARVEOUT_MAX_L1 = 0,
}
pub use self::CUshared_carveout_enum as CUshared_carveout;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUmemorytype_enum {
    CU_MEMORYTYPE_HOST = 1,
    CU_MEMORYTYPE_DEVICE = 2,
    CU_MEMORYTYPE_ARRAY = 3,
    CU_MEMORYTYPE_UNIFIED = 4,
}
pub use self::CUmemorytype_enum as CUmemorytype;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUcomputemode_enum {
    CU_COMPUTEMODE_DEFAULT = 0,
    CU_COMPUTEMODE_PROHIBITED = 2,
    CU_COMPUTEMODE_EXCLUSIVE_PROCESS = 3,
}
pub use self::CUcomputemode_enum as CUcomputemode;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUmem_advise_enum {
    CU_MEM_ADVISE_SET_READ_MOSTLY = 1,
    CU_MEM_ADVISE_UNSET_READ_MOSTLY = 2,
    CU_MEM_ADVISE_SET_PREFERRED_LOCATION = 3,
    CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION = 4,
    CU_MEM_ADVISE_SET_ACCESSED_BY = 5,
    CU_MEM_ADVISE_UNSET_ACCESSED_BY = 6,
}
pub use self::CUmem_advise_enum as CUmem_advise;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUmem_range_attribute_enum {
    CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY = 1,
    CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION = 2,
    CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY = 3,
    CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION = 4,
}
pub use self::CUmem_range_attribute_enum as CUmem_range_attribute;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUjit_option_enum {
    CU_JIT_MAX_REGISTERS = 0,
    CU_JIT_THREADS_PER_BLOCK = 1,
    CU_JIT_WALL_TIME = 2,
    CU_JIT_INFO_LOG_BUFFER = 3,
    CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES = 4,
    CU_JIT_ERROR_LOG_BUFFER = 5,
    CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES = 6,
    CU_JIT_OPTIMIZATION_LEVEL = 7,
    CU_JIT_TARGET_FROM_CUCONTEXT = 8,
    CU_JIT_TARGET = 9,
    CU_JIT_FALLBACK_STRATEGY = 10,
    CU_JIT_GENERATE_DEBUG_INFO = 11,
    CU_JIT_LOG_VERBOSE = 12,
    CU_JIT_GENERATE_LINE_INFO = 13,
    CU_JIT_CACHE_MODE = 14,
    CU_JIT_NEW_SM3X_OPT = 15,
    CU_JIT_FAST_COMPILE = 16,
    CU_JIT_GLOBAL_SYMBOL_NAMES = 17,
    CU_JIT_GLOBAL_SYMBOL_ADDRESSES = 18,
    CU_JIT_GLOBAL_SYMBOL_COUNT = 19,
    CU_JIT_LTO = 20,
    CU_JIT_FTZ = 21,
    CU_JIT_PREC_DIV = 22,
    CU_JIT_PREC_SQRT = 23,
    CU_JIT_FMA = 24,
    CU_JIT_NUM_OPTIONS = 25,
}
pub use self::CUjit_option_enum as CUjit_option;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUjit_target_enum {
    CU_TARGET_COMPUTE_20 = 20,
    CU_TARGET_COMPUTE_21 = 21,
    CU_TARGET_COMPUTE_30 = 30,
    CU_TARGET_COMPUTE_32 = 32,
    CU_TARGET_COMPUTE_35 = 35,
    CU_TARGET_COMPUTE_37 = 37,
    CU_TARGET_COMPUTE_50 = 50,
    CU_TARGET_COMPUTE_52 = 52,
    CU_TARGET_COMPUTE_53 = 53,
    CU_TARGET_COMPUTE_60 = 60,
    CU_TARGET_COMPUTE_61 = 61,
    CU_TARGET_COMPUTE_62 = 62,
    CU_TARGET_COMPUTE_70 = 70,
    CU_TARGET_COMPUTE_72 = 72,
    CU_TARGET_COMPUTE_75 = 75,
    CU_TARGET_COMPUTE_80 = 80,
    CU_TARGET_COMPUTE_86 = 86,
}
pub use self::CUjit_target_enum as CUjit_target;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUjit_fallback_enum {
    CU_PREFER_PTX = 0,
    CU_PREFER_BINARY = 1,
}
pub use self::CUjit_fallback_enum as CUjit_fallback;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUjit_cacheMode_enum {
    CU_JIT_CACHE_OPTION_NONE = 0,
    CU_JIT_CACHE_OPTION_CG = 1,
    CU_JIT_CACHE_OPTION_CA = 2,
}
pub use self::CUjit_cacheMode_enum as CUjit_cacheMode;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUjitInputType_enum {
    CU_JIT_INPUT_CUBIN = 0,
    CU_JIT_INPUT_PTX = 1,
    CU_JIT_INPUT_FATBINARY = 2,
    CU_JIT_INPUT_OBJECT = 3,
    CU_JIT_INPUT_LIBRARY = 4,
    CU_JIT_INPUT_NVVM = 5,
    CU_JIT_NUM_INPUT_TYPES = 6,
}
pub use self::CUjitInputType_enum as CUjitInputType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUlinkState_st {
    _unused: [u8; 0],
}
pub type CUlinkState = *mut CUlinkState_st;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUgraphicsRegisterFlags_enum {
    CU_GRAPHICS_REGISTER_FLAGS_NONE = 0,
    CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY = 1,
    CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD = 2,
    CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST = 4,
    CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER = 8,
}
pub use self::CUgraphicsRegisterFlags_enum as CUgraphicsRegisterFlags;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUgraphicsMapResourceFlags_enum {
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE = 0,
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY = 1,
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD = 2,
}
pub use self::CUgraphicsMapResourceFlags_enum as CUgraphicsMapResourceFlags;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUarray_cubemap_face_enum {
    CU_CUBEMAP_FACE_POSITIVE_X = 0,
    CU_CUBEMAP_FACE_NEGATIVE_X = 1,
    CU_CUBEMAP_FACE_POSITIVE_Y = 2,
    CU_CUBEMAP_FACE_NEGATIVE_Y = 3,
    CU_CUBEMAP_FACE_POSITIVE_Z = 4,
    CU_CUBEMAP_FACE_NEGATIVE_Z = 5,
}
pub use self::CUarray_cubemap_face_enum as CUarray_cubemap_face;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUlimit_enum {
    CU_LIMIT_STACK_SIZE = 0,
    CU_LIMIT_PRINTF_FIFO_SIZE = 1,
    CU_LIMIT_MALLOC_HEAP_SIZE = 2,
    CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH = 3,
    CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT = 4,
    CU_LIMIT_MAX_L2_FETCH_GRANULARITY = 5,
    CU_LIMIT_PERSISTING_L2_CACHE_SIZE = 6,
    CU_LIMIT_MAX = 7,
}
pub use self::CUlimit_enum as CUlimit;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUresourcetype_enum {
    CU_RESOURCE_TYPE_ARRAY = 0,
    CU_RESOURCE_TYPE_MIPMAPPED_ARRAY = 1,
    CU_RESOURCE_TYPE_LINEAR = 2,
    CU_RESOURCE_TYPE_PITCH2D = 3,
}
pub use self::CUresourcetype_enum as CUresourcetype;
pub type CUhostFn =
    ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void)>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUaccessProperty_enum {
    CU_ACCESS_PROPERTY_NORMAL = 0,
    CU_ACCESS_PROPERTY_STREAMING = 1,
    CU_ACCESS_PROPERTY_PERSISTING = 2,
}
pub use self::CUaccessProperty_enum as CUaccessProperty;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct CUaccessPolicyWindow_st {
    pub base_ptr: *mut ::std::os::raw::c_void,
    pub num_bytes: usize,
    pub hitRatio: f32,
    pub hitProp: CUaccessProperty,
    pub missProp: CUaccessProperty,
}
#[test]
fn bindgen_test_layout_CUaccessPolicyWindow_st() {
    assert_eq!(
        ::std::mem::size_of::<CUaccessPolicyWindow_st>(),
        32usize,
        concat!("Size of: ", stringify!(CUaccessPolicyWindow_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUaccessPolicyWindow_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUaccessPolicyWindow_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUaccessPolicyWindow_st>())).base_ptr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUaccessPolicyWindow_st),
            "::",
            stringify!(base_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUaccessPolicyWindow_st>())).num_bytes as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUaccessPolicyWindow_st),
            "::",
            stringify!(num_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUaccessPolicyWindow_st>())).hitRatio as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUaccessPolicyWindow_st),
            "::",
            stringify!(hitRatio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUaccessPolicyWindow_st>())).hitProp as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUaccessPolicyWindow_st),
            "::",
            stringify!(hitProp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUaccessPolicyWindow_st>())).missProp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUaccessPolicyWindow_st),
            "::",
            stringify!(missProp)
        )
    );
}
impl Default for CUaccessPolicyWindow_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUaccessPolicyWindow_v1 = CUaccessPolicyWindow_st;
pub type CUaccessPolicyWindow = CUaccessPolicyWindow_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_KERNEL_NODE_PARAMS_st {
    pub func: CUfunction,
    pub gridDimX: ::std::os::raw::c_uint,
    pub gridDimY: ::std::os::raw::c_uint,
    pub gridDimZ: ::std::os::raw::c_uint,
    pub blockDimX: ::std::os::raw::c_uint,
    pub blockDimY: ::std::os::raw::c_uint,
    pub blockDimZ: ::std::os::raw::c_uint,
    pub sharedMemBytes: ::std::os::raw::c_uint,
    pub kernelParams: *mut *mut ::std::os::raw::c_void,
    pub extra: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_CUDA_KERNEL_NODE_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_KERNEL_NODE_PARAMS_st>(),
        56usize,
        concat!("Size of: ", stringify!(CUDA_KERNEL_NODE_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_KERNEL_NODE_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_KERNEL_NODE_PARAMS_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_KERNEL_NODE_PARAMS_st>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_KERNEL_NODE_PARAMS_st>())).gridDimX as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(gridDimX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_KERNEL_NODE_PARAMS_st>())).gridDimY as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(gridDimY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_KERNEL_NODE_PARAMS_st>())).gridDimZ as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(gridDimZ)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_KERNEL_NODE_PARAMS_st>())).blockDimX as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(blockDimX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_KERNEL_NODE_PARAMS_st>())).blockDimY as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(blockDimY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_KERNEL_NODE_PARAMS_st>())).blockDimZ as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(blockDimZ)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_KERNEL_NODE_PARAMS_st>())).sharedMemBytes as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(sharedMemBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_KERNEL_NODE_PARAMS_st>())).kernelParams as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(kernelParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_KERNEL_NODE_PARAMS_st>())).extra as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(extra)
        )
    );
}
impl Default for CUDA_KERNEL_NODE_PARAMS_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUDA_KERNEL_NODE_PARAMS_v1 = CUDA_KERNEL_NODE_PARAMS_st;
pub type CUDA_KERNEL_NODE_PARAMS = CUDA_KERNEL_NODE_PARAMS_v1;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_MEMSET_NODE_PARAMS_st {
    pub dst: CUdeviceptr,
    pub pitch: usize,
    pub value: ::std::os::raw::c_uint,
    pub elementSize: ::std::os::raw::c_uint,
    pub width: usize,
    pub height: usize,
}
#[test]
fn bindgen_test_layout_CUDA_MEMSET_NODE_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_MEMSET_NODE_PARAMS_st>(),
        40usize,
        concat!("Size of: ", stringify!(CUDA_MEMSET_NODE_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_MEMSET_NODE_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_MEMSET_NODE_PARAMS_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMSET_NODE_PARAMS_st>())).dst as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_st),
            "::",
            stringify!(dst)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMSET_NODE_PARAMS_st>())).pitch as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_st),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMSET_NODE_PARAMS_st>())).value as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_st),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMSET_NODE_PARAMS_st>())).elementSize as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_st),
            "::",
            stringify!(elementSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMSET_NODE_PARAMS_st>())).width as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_st),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMSET_NODE_PARAMS_st>())).height as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_st),
            "::",
            stringify!(height)
        )
    );
}
pub type CUDA_MEMSET_NODE_PARAMS_v1 = CUDA_MEMSET_NODE_PARAMS_st;
pub type CUDA_MEMSET_NODE_PARAMS = CUDA_MEMSET_NODE_PARAMS_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_HOST_NODE_PARAMS_st {
    pub fn_: CUhostFn,
    pub userData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_CUDA_HOST_NODE_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_HOST_NODE_PARAMS_st>(),
        16usize,
        concat!("Size of: ", stringify!(CUDA_HOST_NODE_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_HOST_NODE_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_HOST_NODE_PARAMS_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_HOST_NODE_PARAMS_st>())).fn_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_HOST_NODE_PARAMS_st),
            "::",
            stringify!(fn_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_HOST_NODE_PARAMS_st>())).userData as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_HOST_NODE_PARAMS_st),
            "::",
            stringify!(userData)
        )
    );
}
impl Default for CUDA_HOST_NODE_PARAMS_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUDA_HOST_NODE_PARAMS_v1 = CUDA_HOST_NODE_PARAMS_st;
pub type CUDA_HOST_NODE_PARAMS = CUDA_HOST_NODE_PARAMS_v1;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUgraphNodeType_enum {
    CU_GRAPH_NODE_TYPE_KERNEL = 0,
    CU_GRAPH_NODE_TYPE_MEMCPY = 1,
    CU_GRAPH_NODE_TYPE_MEMSET = 2,
    CU_GRAPH_NODE_TYPE_HOST = 3,
    CU_GRAPH_NODE_TYPE_GRAPH = 4,
    CU_GRAPH_NODE_TYPE_EMPTY = 5,
    CU_GRAPH_NODE_TYPE_WAIT_EVENT = 6,
    CU_GRAPH_NODE_TYPE_EVENT_RECORD = 7,
    CU_GRAPH_NODE_TYPE_EXT_SEMAS_SIGNAL = 8,
    CU_GRAPH_NODE_TYPE_EXT_SEMAS_WAIT = 9,
    CU_GRAPH_NODE_TYPE_MEM_ALLOC = 10,
    CU_GRAPH_NODE_TYPE_MEM_FREE = 11,
}
pub use self::CUgraphNodeType_enum as CUgraphNodeType;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUsynchronizationPolicy_enum {
    CU_SYNC_POLICY_AUTO = 1,
    CU_SYNC_POLICY_SPIN = 2,
    CU_SYNC_POLICY_YIELD = 3,
    CU_SYNC_POLICY_BLOCKING_SYNC = 4,
}
pub use self::CUsynchronizationPolicy_enum as CUsynchronizationPolicy;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUkernelNodeAttrID_enum {
    CU_KERNEL_NODE_ATTRIBUTE_ACCESS_POLICY_WINDOW = 1,
    CU_KERNEL_NODE_ATTRIBUTE_COOPERATIVE = 2,
}
pub use self::CUkernelNodeAttrID_enum as CUkernelNodeAttrID;
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUkernelNodeAttrValue_union {
    pub accessPolicyWindow: CUaccessPolicyWindow,
    pub cooperative: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CUkernelNodeAttrValue_union() {
    assert_eq!(
        ::std::mem::size_of::<CUkernelNodeAttrValue_union>(),
        32usize,
        concat!("Size of: ", stringify!(CUkernelNodeAttrValue_union))
    );
    assert_eq!(
        ::std::mem::align_of::<CUkernelNodeAttrValue_union>(),
        8usize,
        concat!("Alignment of ", stringify!(CUkernelNodeAttrValue_union))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUkernelNodeAttrValue_union>())).accessPolicyWindow as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUkernelNodeAttrValue_union),
            "::",
            stringify!(accessPolicyWindow)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUkernelNodeAttrValue_union>())).cooperative as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUkernelNodeAttrValue_union),
            "::",
            stringify!(cooperative)
        )
    );
}
impl Default for CUkernelNodeAttrValue_union {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUkernelNodeAttrValue_v1 = CUkernelNodeAttrValue_union;
pub type CUkernelNodeAttrValue = CUkernelNodeAttrValue_v1;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUstreamCaptureStatus_enum {
    CU_STREAM_CAPTURE_STATUS_NONE = 0,
    CU_STREAM_CAPTURE_STATUS_ACTIVE = 1,
    CU_STREAM_CAPTURE_STATUS_INVALIDATED = 2,
}
pub use self::CUstreamCaptureStatus_enum as CUstreamCaptureStatus;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUstreamCaptureMode_enum {
    CU_STREAM_CAPTURE_MODE_GLOBAL = 0,
    CU_STREAM_CAPTURE_MODE_THREAD_LOCAL = 1,
    CU_STREAM_CAPTURE_MODE_RELAXED = 2,
}
pub use self::CUstreamCaptureMode_enum as CUstreamCaptureMode;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUstreamAttrID_enum {
    CU_STREAM_ATTRIBUTE_ACCESS_POLICY_WINDOW = 1,
    CU_STREAM_ATTRIBUTE_SYNCHRONIZATION_POLICY = 3,
}
pub use self::CUstreamAttrID_enum as CUstreamAttrID;
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUstreamAttrValue_union {
    pub accessPolicyWindow: CUaccessPolicyWindow,
    pub syncPolicy: CUsynchronizationPolicy,
}
#[test]
fn bindgen_test_layout_CUstreamAttrValue_union() {
    assert_eq!(
        ::std::mem::size_of::<CUstreamAttrValue_union>(),
        32usize,
        concat!("Size of: ", stringify!(CUstreamAttrValue_union))
    );
    assert_eq!(
        ::std::mem::align_of::<CUstreamAttrValue_union>(),
        8usize,
        concat!("Alignment of ", stringify!(CUstreamAttrValue_union))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamAttrValue_union>())).accessPolicyWindow as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamAttrValue_union),
            "::",
            stringify!(accessPolicyWindow)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUstreamAttrValue_union>())).syncPolicy as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamAttrValue_union),
            "::",
            stringify!(syncPolicy)
        )
    );
}
impl Default for CUstreamAttrValue_union {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUstreamAttrValue_v1 = CUstreamAttrValue_union;
pub type CUstreamAttrValue = CUstreamAttrValue_v1;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUdriverProcAddress_flags_enum {
    CU_GET_PROC_ADDRESS_DEFAULT = 0,
    CU_GET_PROC_ADDRESS_LEGACY_STREAM = 1,
    CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM = 2,
}
pub use self::CUdriverProcAddress_flags_enum as CUdriverProcAddress_flags;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUexecAffinityType_enum {
    CU_EXEC_AFFINITY_TYPE_SM_COUNT = 0,
    CU_EXEC_AFFINITY_TYPE_MAX = 1,
}
pub use self::CUexecAffinityType_enum as CUexecAffinityType;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUexecAffinitySmCount_st {
    pub val: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUexecAffinitySmCount_st() {
    assert_eq!(
        ::std::mem::size_of::<CUexecAffinitySmCount_st>(),
        4usize,
        concat!("Size of: ", stringify!(CUexecAffinitySmCount_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUexecAffinitySmCount_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUexecAffinitySmCount_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUexecAffinitySmCount_st>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUexecAffinitySmCount_st),
            "::",
            stringify!(val)
        )
    );
}
pub type CUexecAffinitySmCount_v1 = CUexecAffinitySmCount_st;
pub type CUexecAffinitySmCount = CUexecAffinitySmCount_v1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUexecAffinityParam_st {
    pub type_: CUexecAffinityType,
    pub param: CUexecAffinityParam_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUexecAffinityParam_st__bindgen_ty_1 {
    pub smCount: CUexecAffinitySmCount,
}
#[test]
fn bindgen_test_layout_CUexecAffinityParam_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUexecAffinityParam_st__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(CUexecAffinityParam_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUexecAffinityParam_st__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUexecAffinityParam_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUexecAffinityParam_st__bindgen_ty_1>())).smCount as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUexecAffinityParam_st__bindgen_ty_1),
            "::",
            stringify!(smCount)
        )
    );
}
impl Default for CUexecAffinityParam_st__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_CUexecAffinityParam_st() {
    assert_eq!(
        ::std::mem::size_of::<CUexecAffinityParam_st>(),
        8usize,
        concat!("Size of: ", stringify!(CUexecAffinityParam_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUexecAffinityParam_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUexecAffinityParam_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUexecAffinityParam_st>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUexecAffinityParam_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUexecAffinityParam_st>())).param as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUexecAffinityParam_st),
            "::",
            stringify!(param)
        )
    );
}
impl Default for CUexecAffinityParam_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUexecAffinityParam_v1 = CUexecAffinityParam_st;
pub type CUexecAffinityParam = CUexecAffinityParam_v1;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum cudaError_enum {
    CUDA_SUCCESS = 0,
    CUDA_ERROR_INVALID_VALUE = 1,
    CUDA_ERROR_OUT_OF_MEMORY = 2,
    CUDA_ERROR_NOT_INITIALIZED = 3,
    CUDA_ERROR_DEINITIALIZED = 4,
    CUDA_ERROR_PROFILER_DISABLED = 5,
    CUDA_ERROR_PROFILER_NOT_INITIALIZED = 6,
    CUDA_ERROR_PROFILER_ALREADY_STARTED = 7,
    CUDA_ERROR_PROFILER_ALREADY_STOPPED = 8,
    CUDA_ERROR_STUB_LIBRARY = 34,
    CUDA_ERROR_NO_DEVICE = 100,
    CUDA_ERROR_INVALID_DEVICE = 101,
    CUDA_ERROR_DEVICE_NOT_LICENSED = 102,
    CUDA_ERROR_INVALID_IMAGE = 200,
    CUDA_ERROR_INVALID_CONTEXT = 201,
    CUDA_ERROR_CONTEXT_ALREADY_CURRENT = 202,
    CUDA_ERROR_MAP_FAILED = 205,
    CUDA_ERROR_UNMAP_FAILED = 206,
    CUDA_ERROR_ARRAY_IS_MAPPED = 207,
    CUDA_ERROR_ALREADY_MAPPED = 208,
    CUDA_ERROR_NO_BINARY_FOR_GPU = 209,
    CUDA_ERROR_ALREADY_ACQUIRED = 210,
    CUDA_ERROR_NOT_MAPPED = 211,
    CUDA_ERROR_NOT_MAPPED_AS_ARRAY = 212,
    CUDA_ERROR_NOT_MAPPED_AS_POINTER = 213,
    CUDA_ERROR_ECC_UNCORRECTABLE = 214,
    CUDA_ERROR_UNSUPPORTED_LIMIT = 215,
    CUDA_ERROR_CONTEXT_ALREADY_IN_USE = 216,
    CUDA_ERROR_PEER_ACCESS_UNSUPPORTED = 217,
    CUDA_ERROR_INVALID_PTX = 218,
    CUDA_ERROR_INVALID_GRAPHICS_CONTEXT = 219,
    CUDA_ERROR_NVLINK_UNCORRECTABLE = 220,
    CUDA_ERROR_JIT_COMPILER_NOT_FOUND = 221,
    CUDA_ERROR_UNSUPPORTED_PTX_VERSION = 222,
    CUDA_ERROR_JIT_COMPILATION_DISABLED = 223,
    CUDA_ERROR_UNSUPPORTED_EXEC_AFFINITY = 224,
    CUDA_ERROR_INVALID_SOURCE = 300,
    CUDA_ERROR_FILE_NOT_FOUND = 301,
    CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND = 302,
    CUDA_ERROR_SHARED_OBJECT_INIT_FAILED = 303,
    CUDA_ERROR_OPERATING_SYSTEM = 304,
    CUDA_ERROR_INVALID_HANDLE = 400,
    CUDA_ERROR_ILLEGAL_STATE = 401,
    CUDA_ERROR_NOT_FOUND = 500,
    CUDA_ERROR_NOT_READY = 600,
    CUDA_ERROR_ILLEGAL_ADDRESS = 700,
    CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES = 701,
    CUDA_ERROR_LAUNCH_TIMEOUT = 702,
    CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING = 703,
    CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED = 704,
    CUDA_ERROR_PEER_ACCESS_NOT_ENABLED = 705,
    CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE = 708,
    CUDA_ERROR_CONTEXT_IS_DESTROYED = 709,
    CUDA_ERROR_ASSERT = 710,
    CUDA_ERROR_TOO_MANY_PEERS = 711,
    CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED = 712,
    CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED = 713,
    CUDA_ERROR_HARDWARE_STACK_ERROR = 714,
    CUDA_ERROR_ILLEGAL_INSTRUCTION = 715,
    CUDA_ERROR_MISALIGNED_ADDRESS = 716,
    CUDA_ERROR_INVALID_ADDRESS_SPACE = 717,
    CUDA_ERROR_INVALID_PC = 718,
    CUDA_ERROR_LAUNCH_FAILED = 719,
    CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE = 720,
    CUDA_ERROR_NOT_PERMITTED = 800,
    CUDA_ERROR_NOT_SUPPORTED = 801,
    CUDA_ERROR_SYSTEM_NOT_READY = 802,
    CUDA_ERROR_SYSTEM_DRIVER_MISMATCH = 803,
    CUDA_ERROR_COMPAT_NOT_SUPPORTED_ON_DEVICE = 804,
    CUDA_ERROR_MPS_CONNECTION_FAILED = 805,
    CUDA_ERROR_MPS_RPC_FAILURE = 806,
    CUDA_ERROR_MPS_SERVER_NOT_READY = 807,
    CUDA_ERROR_MPS_MAX_CLIENTS_REACHED = 808,
    CUDA_ERROR_MPS_MAX_CONNECTIONS_REACHED = 809,
    CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED = 900,
    CUDA_ERROR_STREAM_CAPTURE_INVALIDATED = 901,
    CUDA_ERROR_STREAM_CAPTURE_MERGE = 902,
    CUDA_ERROR_STREAM_CAPTURE_UNMATCHED = 903,
    CUDA_ERROR_STREAM_CAPTURE_UNJOINED = 904,
    CUDA_ERROR_STREAM_CAPTURE_ISOLATION = 905,
    CUDA_ERROR_STREAM_CAPTURE_IMPLICIT = 906,
    CUDA_ERROR_CAPTURED_EVENT = 907,
    CUDA_ERROR_STREAM_CAPTURE_WRONG_THREAD = 908,
    CUDA_ERROR_TIMEOUT = 909,
    CUDA_ERROR_GRAPH_EXEC_UPDATE_FAILURE = 910,
    CUDA_ERROR_EXTERNAL_DEVICE = 911,
    CUDA_ERROR_UNKNOWN = 999,
}
pub use self::cudaError_enum as CUresult;
impl CUdevice_P2PAttribute_enum {
    pub const CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED: CUdevice_P2PAttribute_enum =
        CUdevice_P2PAttribute_enum::CU_DEVICE_P2P_ATTRIBUTE_ACCESS_ACCESS_SUPPORTED;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUdevice_P2PAttribute_enum {
    CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK = 1,
    CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED = 2,
    CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED = 3,
    CU_DEVICE_P2P_ATTRIBUTE_ACCESS_ACCESS_SUPPORTED = 4,
}
pub use self::CUdevice_P2PAttribute_enum as CUdevice_P2PAttribute;
pub type CUstreamCallback = ::std::option::Option<
    unsafe extern "C" fn(
        hStream: CUstream,
        status: CUresult,
        userData: *mut ::std::os::raw::c_void,
    ),
>;
pub type CUoccupancyB2DSize =
    ::std::option::Option<unsafe extern "C" fn(blockSize: ::std::os::raw::c_int) -> usize>;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_MEMCPY2D_st {
    pub srcXInBytes: usize,
    pub srcY: usize,
    pub srcMemoryType: CUmemorytype,
    pub srcHost: *const ::std::os::raw::c_void,
    pub srcDevice: CUdeviceptr,
    pub srcArray: CUarray,
    pub srcPitch: usize,
    pub dstXInBytes: usize,
    pub dstY: usize,
    pub dstMemoryType: CUmemorytype,
    pub dstHost: *mut ::std::os::raw::c_void,
    pub dstDevice: CUdeviceptr,
    pub dstArray: CUarray,
    pub dstPitch: usize,
    pub WidthInBytes: usize,
    pub Height: usize,
}
#[test]
fn bindgen_test_layout_CUDA_MEMCPY2D_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_MEMCPY2D_st>(),
        128usize,
        concat!("Size of: ", stringify!(CUDA_MEMCPY2D_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_MEMCPY2D_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_MEMCPY2D_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).srcXInBytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcXInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).srcY as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).srcMemoryType as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcMemoryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).srcHost as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcHost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).srcDevice as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).srcArray as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).srcPitch as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).dstXInBytes as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstXInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).dstY as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).dstMemoryType as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstMemoryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).dstHost as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstHost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).dstDevice as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).dstArray as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).dstPitch as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).WidthInBytes as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(WidthInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY2D_st>())).Height as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(Height)
        )
    );
}
impl Default for CUDA_MEMCPY2D_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUDA_MEMCPY2D_v2 = CUDA_MEMCPY2D_st;
pub type CUDA_MEMCPY2D = CUDA_MEMCPY2D_v2;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_MEMCPY3D_st {
    pub srcXInBytes: usize,
    pub srcY: usize,
    pub srcZ: usize,
    pub srcLOD: usize,
    pub srcMemoryType: CUmemorytype,
    pub srcHost: *const ::std::os::raw::c_void,
    pub srcDevice: CUdeviceptr,
    pub srcArray: CUarray,
    pub reserved0: *mut ::std::os::raw::c_void,
    pub srcPitch: usize,
    pub srcHeight: usize,
    pub dstXInBytes: usize,
    pub dstY: usize,
    pub dstZ: usize,
    pub dstLOD: usize,
    pub dstMemoryType: CUmemorytype,
    pub dstHost: *mut ::std::os::raw::c_void,
    pub dstDevice: CUdeviceptr,
    pub dstArray: CUarray,
    pub reserved1: *mut ::std::os::raw::c_void,
    pub dstPitch: usize,
    pub dstHeight: usize,
    pub WidthInBytes: usize,
    pub Height: usize,
    pub Depth: usize,
}
#[test]
fn bindgen_test_layout_CUDA_MEMCPY3D_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_MEMCPY3D_st>(),
        200usize,
        concat!("Size of: ", stringify!(CUDA_MEMCPY3D_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_MEMCPY3D_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_MEMCPY3D_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).srcXInBytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcXInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).srcY as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).srcZ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).srcLOD as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcLOD)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).srcMemoryType as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcMemoryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).srcHost as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcHost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).srcDevice as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).srcArray as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).reserved0 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).srcPitch as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).srcHeight as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).dstXInBytes as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstXInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).dstY as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).dstZ as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).dstLOD as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstLOD)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).dstMemoryType as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstMemoryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).dstHost as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstHost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).dstDevice as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).dstArray as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).reserved1 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).dstPitch as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).dstHeight as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).WidthInBytes as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(WidthInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).Height as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_st>())).Depth as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(Depth)
        )
    );
}
impl Default for CUDA_MEMCPY3D_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUDA_MEMCPY3D_v2 = CUDA_MEMCPY3D_st;
pub type CUDA_MEMCPY3D = CUDA_MEMCPY3D_v2;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_MEMCPY3D_PEER_st {
    pub srcXInBytes: usize,
    pub srcY: usize,
    pub srcZ: usize,
    pub srcLOD: usize,
    pub srcMemoryType: CUmemorytype,
    pub srcHost: *const ::std::os::raw::c_void,
    pub srcDevice: CUdeviceptr,
    pub srcArray: CUarray,
    pub srcContext: CUcontext,
    pub srcPitch: usize,
    pub srcHeight: usize,
    pub dstXInBytes: usize,
    pub dstY: usize,
    pub dstZ: usize,
    pub dstLOD: usize,
    pub dstMemoryType: CUmemorytype,
    pub dstHost: *mut ::std::os::raw::c_void,
    pub dstDevice: CUdeviceptr,
    pub dstArray: CUarray,
    pub dstContext: CUcontext,
    pub dstPitch: usize,
    pub dstHeight: usize,
    pub WidthInBytes: usize,
    pub Height: usize,
    pub Depth: usize,
}
#[test]
fn bindgen_test_layout_CUDA_MEMCPY3D_PEER_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_MEMCPY3D_PEER_st>(),
        200usize,
        concat!("Size of: ", stringify!(CUDA_MEMCPY3D_PEER_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_MEMCPY3D_PEER_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_MEMCPY3D_PEER_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcXInBytes as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcXInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcY as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcZ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcLOD as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcLOD)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcMemoryType as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcMemoryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcHost as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcHost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcDevice as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcArray as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcContext as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcPitch as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).srcHeight as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstXInBytes as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstXInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstY as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstZ as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstLOD as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstLOD)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstMemoryType as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstMemoryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstHost as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstHost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstDevice as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstArray as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstContext as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstPitch as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).dstHeight as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).WidthInBytes as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(WidthInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).Height as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_MEMCPY3D_PEER_st>())).Depth as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(Depth)
        )
    );
}
impl Default for CUDA_MEMCPY3D_PEER_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUDA_MEMCPY3D_PEER_v1 = CUDA_MEMCPY3D_PEER_st;
pub type CUDA_MEMCPY3D_PEER = CUDA_MEMCPY3D_PEER_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_ARRAY_DESCRIPTOR_st {
    pub Width: usize,
    pub Height: usize,
    pub Format: CUarray_format,
    pub NumChannels: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_ARRAY_DESCRIPTOR_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_ARRAY_DESCRIPTOR_st>(),
        24usize,
        concat!("Size of: ", stringify!(CUDA_ARRAY_DESCRIPTOR_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_ARRAY_DESCRIPTOR_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_ARRAY_DESCRIPTOR_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_ARRAY_DESCRIPTOR_st>())).Width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_DESCRIPTOR_st),
            "::",
            stringify!(Width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_ARRAY_DESCRIPTOR_st>())).Height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_DESCRIPTOR_st),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_ARRAY_DESCRIPTOR_st>())).Format as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_DESCRIPTOR_st),
            "::",
            stringify!(Format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY_DESCRIPTOR_st>())).NumChannels as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_DESCRIPTOR_st),
            "::",
            stringify!(NumChannels)
        )
    );
}
impl Default for CUDA_ARRAY_DESCRIPTOR_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUDA_ARRAY_DESCRIPTOR_v2 = CUDA_ARRAY_DESCRIPTOR_st;
pub type CUDA_ARRAY_DESCRIPTOR = CUDA_ARRAY_DESCRIPTOR_v2;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_ARRAY3D_DESCRIPTOR_st {
    pub Width: usize,
    pub Height: usize,
    pub Depth: usize,
    pub Format: CUarray_format,
    pub NumChannels: ::std::os::raw::c_uint,
    pub Flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_ARRAY3D_DESCRIPTOR_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_ARRAY3D_DESCRIPTOR_st>(),
        40usize,
        concat!("Size of: ", stringify!(CUDA_ARRAY3D_DESCRIPTOR_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_ARRAY3D_DESCRIPTOR_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_ARRAY3D_DESCRIPTOR_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY3D_DESCRIPTOR_st>())).Width as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
            "::",
            stringify!(Width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY3D_DESCRIPTOR_st>())).Height as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY3D_DESCRIPTOR_st>())).Depth as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
            "::",
            stringify!(Depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY3D_DESCRIPTOR_st>())).Format as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
            "::",
            stringify!(Format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY3D_DESCRIPTOR_st>())).NumChannels as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
            "::",
            stringify!(NumChannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY3D_DESCRIPTOR_st>())).Flags as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
            "::",
            stringify!(Flags)
        )
    );
}
impl Default for CUDA_ARRAY3D_DESCRIPTOR_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUDA_ARRAY3D_DESCRIPTOR_v2 = CUDA_ARRAY3D_DESCRIPTOR_st;
pub type CUDA_ARRAY3D_DESCRIPTOR = CUDA_ARRAY3D_DESCRIPTOR_v2;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_ARRAY_SPARSE_PROPERTIES_st {
    pub tileExtent: CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1,
    pub miptailFirstLevel: ::std::os::raw::c_uint,
    pub miptailSize: ::std::os::raw::c_ulonglong,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1 {
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
    pub depth: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1>())).width
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1>())).height
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1>())).depth
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1),
            "::",
            stringify!(depth)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_ARRAY_SPARSE_PROPERTIES_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_ARRAY_SPARSE_PROPERTIES_st>(),
        48usize,
        concat!("Size of: ", stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_ARRAY_SPARSE_PROPERTIES_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY_SPARSE_PROPERTIES_st>())).tileExtent as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st),
            "::",
            stringify!(tileExtent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY_SPARSE_PROPERTIES_st>())).miptailFirstLevel
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st),
            "::",
            stringify!(miptailFirstLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY_SPARSE_PROPERTIES_st>())).miptailSize as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st),
            "::",
            stringify!(miptailSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY_SPARSE_PROPERTIES_st>())).flags as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_ARRAY_SPARSE_PROPERTIES_st>())).reserved as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CUDA_ARRAY_SPARSE_PROPERTIES_v1 = CUDA_ARRAY_SPARSE_PROPERTIES_st;
pub type CUDA_ARRAY_SPARSE_PROPERTIES = CUDA_ARRAY_SPARSE_PROPERTIES_v1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_RESOURCE_DESC_st {
    pub resType: CUresourcetype,
    pub res: CUDA_RESOURCE_DESC_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_RESOURCE_DESC_st__bindgen_ty_1 {
    pub array: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    pub mipmap: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2,
    pub linear: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3,
    pub pitch2D: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4,
    pub reserved: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    pub hArray: CUarray,
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1>())).hArray
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(hArray)
        )
    );
}
impl Default for CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2 {
    pub hMipmappedArray: CUmipmappedArray,
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2>()))
                .hMipmappedArray as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(hMipmappedArray)
        )
    );
}
impl Default for CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3 {
    pub devPtr: CUdeviceptr,
    pub format: CUarray_format,
    pub numChannels: ::std::os::raw::c_uint,
    pub sizeInBytes: usize,
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>())).devPtr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(devPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>())).format
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>()))
                .numChannels as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(numChannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>()))
                .sizeInBytes as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(sizeInBytes)
        )
    );
}
impl Default for CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4 {
    pub devPtr: CUdeviceptr,
    pub format: CUarray_format,
    pub numChannels: ::std::os::raw::c_uint,
    pub width: usize,
    pub height: usize,
    pub pitchInBytes: usize,
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>())).devPtr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(devPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>())).format
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>()))
                .numChannels as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(numChannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>())).width
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>())).height
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>()))
                .pitchInBytes as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(pitchInBytes)
        )
    );
}
impl Default for CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5 {
    pub reserved: [::std::os::raw::c_int; 32usize],
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5>())).reserved
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>())).array as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>())).mipmap as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(mipmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>())).linear as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(linear)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>())).pitch2D as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(pitch2D)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>())).reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUDA_RESOURCE_DESC_st__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st>(),
        144usize,
        concat!("Size of: ", stringify!(CUDA_RESOURCE_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_RESOURCE_DESC_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st>())).resType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st),
            "::",
            stringify!(resType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st>())).res as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st),
            "::",
            stringify!(res)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_RESOURCE_DESC_st>())).flags as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for CUDA_RESOURCE_DESC_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUDA_RESOURCE_DESC_v1 = CUDA_RESOURCE_DESC_st;
pub type CUDA_RESOURCE_DESC = CUDA_RESOURCE_DESC_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct CUDA_TEXTURE_DESC_st {
    pub addressMode: [CUaddress_mode; 3usize],
    pub filterMode: CUfilter_mode,
    pub flags: ::std::os::raw::c_uint,
    pub maxAnisotropy: ::std::os::raw::c_uint,
    pub mipmapFilterMode: CUfilter_mode,
    pub mipmapLevelBias: f32,
    pub minMipmapLevelClamp: f32,
    pub maxMipmapLevelClamp: f32,
    pub borderColor: [f32; 4usize],
    pub reserved: [::std::os::raw::c_int; 12usize],
}
#[test]
fn bindgen_test_layout_CUDA_TEXTURE_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_TEXTURE_DESC_st>(),
        104usize,
        concat!("Size of: ", stringify!(CUDA_TEXTURE_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_TEXTURE_DESC_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUDA_TEXTURE_DESC_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_TEXTURE_DESC_st>())).addressMode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(addressMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_TEXTURE_DESC_st>())).filterMode as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(filterMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_TEXTURE_DESC_st>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_TEXTURE_DESC_st>())).maxAnisotropy as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(maxAnisotropy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_TEXTURE_DESC_st>())).mipmapFilterMode as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(mipmapFilterMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_TEXTURE_DESC_st>())).mipmapLevelBias as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(mipmapLevelBias)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_TEXTURE_DESC_st>())).minMipmapLevelClamp as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(minMipmapLevelClamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_TEXTURE_DESC_st>())).maxMipmapLevelClamp as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(maxMipmapLevelClamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_TEXTURE_DESC_st>())).borderColor as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(borderColor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_TEXTURE_DESC_st>())).reserved as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUDA_TEXTURE_DESC_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUDA_TEXTURE_DESC_v1 = CUDA_TEXTURE_DESC_st;
pub type CUDA_TEXTURE_DESC = CUDA_TEXTURE_DESC_v1;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUresourceViewFormat_enum {
    CU_RES_VIEW_FORMAT_NONE = 0,
    CU_RES_VIEW_FORMAT_UINT_1X8 = 1,
    CU_RES_VIEW_FORMAT_UINT_2X8 = 2,
    CU_RES_VIEW_FORMAT_UINT_4X8 = 3,
    CU_RES_VIEW_FORMAT_SINT_1X8 = 4,
    CU_RES_VIEW_FORMAT_SINT_2X8 = 5,
    CU_RES_VIEW_FORMAT_SINT_4X8 = 6,
    CU_RES_VIEW_FORMAT_UINT_1X16 = 7,
    CU_RES_VIEW_FORMAT_UINT_2X16 = 8,
    CU_RES_VIEW_FORMAT_UINT_4X16 = 9,
    CU_RES_VIEW_FORMAT_SINT_1X16 = 10,
    CU_RES_VIEW_FORMAT_SINT_2X16 = 11,
    CU_RES_VIEW_FORMAT_SINT_4X16 = 12,
    CU_RES_VIEW_FORMAT_UINT_1X32 = 13,
    CU_RES_VIEW_FORMAT_UINT_2X32 = 14,
    CU_RES_VIEW_FORMAT_UINT_4X32 = 15,
    CU_RES_VIEW_FORMAT_SINT_1X32 = 16,
    CU_RES_VIEW_FORMAT_SINT_2X32 = 17,
    CU_RES_VIEW_FORMAT_SINT_4X32 = 18,
    CU_RES_VIEW_FORMAT_FLOAT_1X16 = 19,
    CU_RES_VIEW_FORMAT_FLOAT_2X16 = 20,
    CU_RES_VIEW_FORMAT_FLOAT_4X16 = 21,
    CU_RES_VIEW_FORMAT_FLOAT_1X32 = 22,
    CU_RES_VIEW_FORMAT_FLOAT_2X32 = 23,
    CU_RES_VIEW_FORMAT_FLOAT_4X32 = 24,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC1 = 25,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC2 = 26,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC3 = 27,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC4 = 28,
    CU_RES_VIEW_FORMAT_SIGNED_BC4 = 29,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC5 = 30,
    CU_RES_VIEW_FORMAT_SIGNED_BC5 = 31,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC6H = 32,
    CU_RES_VIEW_FORMAT_SIGNED_BC6H = 33,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC7 = 34,
}
pub use self::CUresourceViewFormat_enum as CUresourceViewFormat;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_RESOURCE_VIEW_DESC_st {
    pub format: CUresourceViewFormat,
    pub width: usize,
    pub height: usize,
    pub depth: usize,
    pub firstMipmapLevel: ::std::os::raw::c_uint,
    pub lastMipmapLevel: ::std::os::raw::c_uint,
    pub firstLayer: ::std::os::raw::c_uint,
    pub lastLayer: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_VIEW_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_VIEW_DESC_st>(),
        112usize,
        concat!("Size of: ", stringify!(CUDA_RESOURCE_VIEW_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_VIEW_DESC_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_RESOURCE_VIEW_DESC_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_VIEW_DESC_st>())).format as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_VIEW_DESC_st>())).width as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_VIEW_DESC_st>())).height as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_VIEW_DESC_st>())).depth as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_VIEW_DESC_st>())).firstMipmapLevel as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(firstMipmapLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_VIEW_DESC_st>())).lastMipmapLevel as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(lastMipmapLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_VIEW_DESC_st>())).firstLayer as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(firstLayer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_VIEW_DESC_st>())).lastLayer as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(lastLayer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_RESOURCE_VIEW_DESC_st>())).reserved as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUDA_RESOURCE_VIEW_DESC_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUDA_RESOURCE_VIEW_DESC_v1 = CUDA_RESOURCE_VIEW_DESC_st;
pub type CUDA_RESOURCE_VIEW_DESC = CUDA_RESOURCE_VIEW_DESC_v1;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st {
    pub p2pToken: ::std::os::raw::c_ulonglong,
    pub vaSpaceToken: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st>())).p2pToken as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st),
            "::",
            stringify!(p2pToken)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st>())).vaSpaceToken
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st),
            "::",
            stringify!(vaSpaceToken)
        )
    );
}
pub type CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_v1 = CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st;
pub type CUDA_POINTER_ATTRIBUTE_P2P_TOKENS = CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_v1;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum {
    CU_POINTER_ATTRIBUTE_ACCESS_FLAG_NONE = 0,
    CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READ = 1,
    CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READWRITE = 3,
}
pub use self::CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum as CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_LAUNCH_PARAMS_st {
    pub function: CUfunction,
    pub gridDimX: ::std::os::raw::c_uint,
    pub gridDimY: ::std::os::raw::c_uint,
    pub gridDimZ: ::std::os::raw::c_uint,
    pub blockDimX: ::std::os::raw::c_uint,
    pub blockDimY: ::std::os::raw::c_uint,
    pub blockDimZ: ::std::os::raw::c_uint,
    pub sharedMemBytes: ::std::os::raw::c_uint,
    pub hStream: CUstream,
    pub kernelParams: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_CUDA_LAUNCH_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_LAUNCH_PARAMS_st>(),
        56usize,
        concat!("Size of: ", stringify!(CUDA_LAUNCH_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_LAUNCH_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_LAUNCH_PARAMS_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_LAUNCH_PARAMS_st>())).function as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_LAUNCH_PARAMS_st>())).gridDimX as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(gridDimX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_LAUNCH_PARAMS_st>())).gridDimY as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(gridDimY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_LAUNCH_PARAMS_st>())).gridDimZ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(gridDimZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_LAUNCH_PARAMS_st>())).blockDimX as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(blockDimX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_LAUNCH_PARAMS_st>())).blockDimY as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(blockDimY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_LAUNCH_PARAMS_st>())).blockDimZ as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(blockDimZ)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_LAUNCH_PARAMS_st>())).sharedMemBytes as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(sharedMemBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUDA_LAUNCH_PARAMS_st>())).hStream as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(hStream)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_LAUNCH_PARAMS_st>())).kernelParams as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(kernelParams)
        )
    );
}
impl Default for CUDA_LAUNCH_PARAMS_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUDA_LAUNCH_PARAMS_v1 = CUDA_LAUNCH_PARAMS_st;
pub type CUDA_LAUNCH_PARAMS = CUDA_LAUNCH_PARAMS_v1;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUexternalMemoryHandleType_enum {
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD = 1,
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32 = 2,
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT = 3,
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP = 4,
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE = 5,
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE = 6,
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT = 7,
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF = 8,
}
pub use self::CUexternalMemoryHandleType_enum as CUexternalMemoryHandleType;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st {
    pub type_: CUexternalMemoryHandleType,
    pub handle: CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1,
    pub size: ::std::os::raw::c_ulonglong,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub win32: CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    pub nvSciBufObject: *const ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    pub handle: *mut ::std::os::raw::c_void,
    pub name: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1>(
            )))
            .handle as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1>(
            )))
            .name as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(name)
        )
    );
}
impl Default for CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1>())).fd
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1>())).win32
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(win32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1>()))
                .nvSciBufObject as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(nvSciBufObject)
        )
    );
}
impl Default for CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>(),
        104usize,
        concat!("Size of: ", stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>())).type_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>())).handle as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>())).size as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>())).flags as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>())).reserved as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1 = CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st;
pub type CUDA_EXTERNAL_MEMORY_HANDLE_DESC = CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st {
    pub offset: ::std::os::raw::c_ulonglong,
    pub size: ::std::os::raw::c_ulonglong,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st>(),
        88usize,
        concat!("Size of: ", stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st>())).offset as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st>())).flags as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st>())).reserved as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CUDA_EXTERNAL_MEMORY_BUFFER_DESC_v1 = CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st;
pub type CUDA_EXTERNAL_MEMORY_BUFFER_DESC = CUDA_EXTERNAL_MEMORY_BUFFER_DESC_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st {
    pub offset: ::std::os::raw::c_ulonglong,
    pub arrayDesc: CUDA_ARRAY3D_DESCRIPTOR,
    pub numLevels: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st>(),
        120usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st>())).offset
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st>())).arrayDesc
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st),
            "::",
            stringify!(arrayDesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st>())).numLevels
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st),
            "::",
            stringify!(numLevels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st>())).reserved
                as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_v1 =
    CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st;
pub type CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC = CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_v1;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUexternalSemaphoreHandleType_enum {
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD = 1,
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32 = 2,
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT = 3,
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE = 4,
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE = 5,
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC = 6,
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX = 7,
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT = 8,
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD = 9,
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32 = 10,
}
pub use self::CUexternalSemaphoreHandleType_enum as CUexternalSemaphoreHandleType;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st {
    pub type_: CUexternalSemaphoreHandleType,
    pub handle: CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub win32: CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSyncObj: *const ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    pub handle: *mut ::std::os::raw::c_void,
    pub name: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
            >()))
            .handle as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
            >()))
            .name as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(name)
        )
    );
}
impl Default for CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1>())).fd
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1>())).win32
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(win32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1>()))
                .nvSciSyncObj as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(nvSciSyncObj)
        )
    );
}
impl Default for CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st>())).type_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st>())).handle as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st>())).flags as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st>())).reserved as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1 = CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st;
pub type CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC = CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st {
    pub params: CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1 {
    pub fence: CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3,
    pub reserved: [::std::os::raw::c_uint; 12usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1 {
    pub value: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1>(
        ),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1,
            >()))
            .value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2 {
    pub fence: *mut ::std::os::raw::c_void,
    pub reserved: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2>(
        ),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2,
            >()))
            .fence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2,
            >()))
            .reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3 {
    pub key: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3>(
        ),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3,
            >()))
            .key as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(key)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1>())).fence
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1>()))
                .nvSciSync as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(nvSciSync)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1>()))
                .keyedMutex as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(keyedMutex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1>()))
                .reserved as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st>())).params as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st>())).flags as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st>())).reserved
                as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1 = CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st;
pub type CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS = CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st {
    pub params: CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1 {
    pub fence: CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3,
    pub reserved: [::std::os::raw::c_uint; 10usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1 {
    pub value: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1,
            >()))
            .value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2 {
    pub fence: *mut ::std::os::raw::c_void,
    pub reserved: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2,
            >()))
            .fence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2,
            >()))
            .reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3 {
    pub key: ::std::os::raw::c_ulonglong,
    pub timeoutMs: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3,
            >()))
            .key as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3,
            >()))
            .timeoutMs as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(timeoutMs)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1>())).fence
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1>()))
                .nvSciSync as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(nvSciSync)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1>()))
                .keyedMutex as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(keyedMutex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1>()))
                .reserved as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st>())).params as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st>())).flags as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st>())).reserved as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1 = CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st;
pub type CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS = CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st {
    pub extSemArray: *mut CUexternalSemaphore,
    pub paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS,
    pub numExtSems: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st>(),
        24usize,
        concat!("Size of: ", stringify!(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st>())).extSemArray as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st),
            "::",
            stringify!(extSemArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st>())).paramsArray as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st),
            "::",
            stringify!(paramsArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st>())).numExtSems as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st),
            "::",
            stringify!(numExtSems)
        )
    );
}
impl Default for CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v1 = CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st;
pub type CUDA_EXT_SEM_SIGNAL_NODE_PARAMS = CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_EXT_SEM_WAIT_NODE_PARAMS_st {
    pub extSemArray: *mut CUexternalSemaphore,
    pub paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS,
    pub numExtSems: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_EXT_SEM_WAIT_NODE_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXT_SEM_WAIT_NODE_PARAMS_st>(),
        24usize,
        concat!("Size of: ", stringify!(CUDA_EXT_SEM_WAIT_NODE_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXT_SEM_WAIT_NODE_PARAMS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXT_SEM_WAIT_NODE_PARAMS_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXT_SEM_WAIT_NODE_PARAMS_st>())).extSemArray as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXT_SEM_WAIT_NODE_PARAMS_st),
            "::",
            stringify!(extSemArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXT_SEM_WAIT_NODE_PARAMS_st>())).paramsArray as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXT_SEM_WAIT_NODE_PARAMS_st),
            "::",
            stringify!(paramsArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_EXT_SEM_WAIT_NODE_PARAMS_st>())).numExtSems as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXT_SEM_WAIT_NODE_PARAMS_st),
            "::",
            stringify!(numExtSems)
        )
    );
}
impl Default for CUDA_EXT_SEM_WAIT_NODE_PARAMS_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUDA_EXT_SEM_WAIT_NODE_PARAMS_v1 = CUDA_EXT_SEM_WAIT_NODE_PARAMS_st;
pub type CUDA_EXT_SEM_WAIT_NODE_PARAMS = CUDA_EXT_SEM_WAIT_NODE_PARAMS_v1;
pub type CUmemGenericAllocationHandle_v1 = ::std::os::raw::c_ulonglong;
pub type CUmemGenericAllocationHandle = CUmemGenericAllocationHandle_v1;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUmemAllocationHandleType_enum {
    CU_MEM_HANDLE_TYPE_NONE = 0,
    CU_MEM_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR = 1,
    CU_MEM_HANDLE_TYPE_WIN32 = 2,
    CU_MEM_HANDLE_TYPE_WIN32_KMT = 4,
    CU_MEM_HANDLE_TYPE_MAX = 2147483647,
}
pub use self::CUmemAllocationHandleType_enum as CUmemAllocationHandleType;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUmemAccess_flags_enum {
    CU_MEM_ACCESS_FLAGS_PROT_NONE = 0,
    CU_MEM_ACCESS_FLAGS_PROT_READ = 1,
    CU_MEM_ACCESS_FLAGS_PROT_READWRITE = 3,
    CU_MEM_ACCESS_FLAGS_PROT_MAX = 2147483647,
}
pub use self::CUmemAccess_flags_enum as CUmemAccess_flags;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUmemLocationType_enum {
    CU_MEM_LOCATION_TYPE_INVALID = 0,
    CU_MEM_LOCATION_TYPE_DEVICE = 1,
    CU_MEM_LOCATION_TYPE_MAX = 2147483647,
}
pub use self::CUmemLocationType_enum as CUmemLocationType;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUmemAllocationType_enum {
    CU_MEM_ALLOCATION_TYPE_INVALID = 0,
    CU_MEM_ALLOCATION_TYPE_PINNED = 1,
    CU_MEM_ALLOCATION_TYPE_MAX = 2147483647,
}
pub use self::CUmemAllocationType_enum as CUmemAllocationType;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUmemAllocationGranularity_flags_enum {
    CU_MEM_ALLOC_GRANULARITY_MINIMUM = 0,
    CU_MEM_ALLOC_GRANULARITY_RECOMMENDED = 1,
}
pub use self::CUmemAllocationGranularity_flags_enum as CUmemAllocationGranularity_flags;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUarraySparseSubresourceType_enum {
    CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL = 0,
    CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL = 1,
}
pub use self::CUarraySparseSubresourceType_enum as CUarraySparseSubresourceType;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUmemOperationType_enum {
    CU_MEM_OPERATION_TYPE_MAP = 1,
    CU_MEM_OPERATION_TYPE_UNMAP = 2,
}
pub use self::CUmemOperationType_enum as CUmemOperationType;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUmemHandleType_enum {
    CU_MEM_HANDLE_TYPE_GENERIC = 0,
}
pub use self::CUmemHandleType_enum as CUmemHandleType;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUarrayMapInfo_st {
    pub resourceType: CUresourcetype,
    pub resource: CUarrayMapInfo_st__bindgen_ty_1,
    pub subresourceType: CUarraySparseSubresourceType,
    pub subresource: CUarrayMapInfo_st__bindgen_ty_2,
    pub memOperationType: CUmemOperationType,
    pub memHandleType: CUmemHandleType,
    pub memHandle: CUarrayMapInfo_st__bindgen_ty_3,
    pub offset: ::std::os::raw::c_ulonglong,
    pub deviceBitMask: ::std::os::raw::c_uint,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUarrayMapInfo_st__bindgen_ty_1 {
    pub mipmap: CUmipmappedArray,
    pub array: CUarray,
}
#[test]
fn bindgen_test_layout_CUarrayMapInfo_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUarrayMapInfo_st__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(CUarrayMapInfo_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<CUarrayMapInfo_st__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(CUarrayMapInfo_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_1>())).mipmap as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_1),
            "::",
            stringify!(mipmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_1>())).array as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_1),
            "::",
            stringify!(array)
        )
    );
}
impl Default for CUarrayMapInfo_st__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUarrayMapInfo_st__bindgen_ty_2 {
    pub sparseLevel: CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1,
    pub miptail: CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1 {
    pub level: ::std::os::raw::c_uint,
    pub layer: ::std::os::raw::c_uint,
    pub offsetX: ::std::os::raw::c_uint,
    pub offsetY: ::std::os::raw::c_uint,
    pub offsetZ: ::std::os::raw::c_uint,
    pub extentWidth: ::std::os::raw::c_uint,
    pub extentHeight: ::std::os::raw::c_uint,
    pub extentDepth: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1>())).level
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1>())).layer
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(layer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1>())).offsetX
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(offsetX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1>())).offsetY
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(offsetY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1>())).offsetZ
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(offsetZ)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1>())).extentWidth
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(extentWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1>())).extentHeight
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(extentHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1>())).extentDepth
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(extentDepth)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2 {
    pub layer: ::std::os::raw::c_uint,
    pub offset: ::std::os::raw::c_ulonglong,
    pub size: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2>())).layer
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(layer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2>())).offset
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2>())).size
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(size)
        )
    );
}
#[test]
fn bindgen_test_layout_CUarrayMapInfo_st__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<CUarrayMapInfo_st__bindgen_ty_2>(),
        32usize,
        concat!("Size of: ", stringify!(CUarrayMapInfo_st__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<CUarrayMapInfo_st__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(CUarrayMapInfo_st__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_2>())).sparseLevel as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2),
            "::",
            stringify!(sparseLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_2>())).miptail as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2),
            "::",
            stringify!(miptail)
        )
    );
}
impl Default for CUarrayMapInfo_st__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUarrayMapInfo_st__bindgen_ty_3 {
    pub memHandle: CUmemGenericAllocationHandle,
}
#[test]
fn bindgen_test_layout_CUarrayMapInfo_st__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<CUarrayMapInfo_st__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(CUarrayMapInfo_st__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<CUarrayMapInfo_st__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(CUarrayMapInfo_st__bindgen_ty_3))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st__bindgen_ty_3>())).memHandle as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_3),
            "::",
            stringify!(memHandle)
        )
    );
}
impl Default for CUarrayMapInfo_st__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_CUarrayMapInfo_st() {
    assert_eq!(
        ::std::mem::size_of::<CUarrayMapInfo_st>(),
        96usize,
        concat!("Size of: ", stringify!(CUarrayMapInfo_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUarrayMapInfo_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUarrayMapInfo_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUarrayMapInfo_st>())).resourceType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(resourceType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUarrayMapInfo_st>())).resource as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(resource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st>())).subresourceType as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(subresourceType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUarrayMapInfo_st>())).subresource as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(subresource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUarrayMapInfo_st>())).memOperationType as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(memOperationType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUarrayMapInfo_st>())).memHandleType as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(memHandleType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUarrayMapInfo_st>())).memHandle as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(memHandle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUarrayMapInfo_st>())).offset as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUarrayMapInfo_st>())).deviceBitMask as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(deviceBitMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUarrayMapInfo_st>())).flags as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUarrayMapInfo_st>())).reserved as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUarrayMapInfo_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUarrayMapInfo_v1 = CUarrayMapInfo_st;
pub type CUarrayMapInfo = CUarrayMapInfo_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUmemLocation_st {
    pub type_: CUmemLocationType,
    pub id: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CUmemLocation_st() {
    assert_eq!(
        ::std::mem::size_of::<CUmemLocation_st>(),
        8usize,
        concat!("Size of: ", stringify!(CUmemLocation_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUmemLocation_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUmemLocation_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUmemLocation_st>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemLocation_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUmemLocation_st>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemLocation_st),
            "::",
            stringify!(id)
        )
    );
}
impl Default for CUmemLocation_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUmemLocation_v1 = CUmemLocation_st;
pub type CUmemLocation = CUmemLocation_v1;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUmemAllocationCompType_enum {
    CU_MEM_ALLOCATION_COMP_NONE = 0,
    CU_MEM_ALLOCATION_COMP_GENERIC = 1,
}
pub use self::CUmemAllocationCompType_enum as CUmemAllocationCompType;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUmemAllocationProp_st {
    pub type_: CUmemAllocationType,
    pub requestedHandleTypes: CUmemAllocationHandleType,
    pub location: CUmemLocation,
    pub win32HandleMetaData: *mut ::std::os::raw::c_void,
    pub allocFlags: CUmemAllocationProp_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUmemAllocationProp_st__bindgen_ty_1 {
    pub compressionType: ::std::os::raw::c_uchar,
    pub gpuDirectRDMACapable: ::std::os::raw::c_uchar,
    pub usage: ::std::os::raw::c_ushort,
    pub reserved: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_CUmemAllocationProp_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUmemAllocationProp_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUmemAllocationProp_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUmemAllocationProp_st__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(CUmemAllocationProp_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUmemAllocationProp_st__bindgen_ty_1>())).compressionType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st__bindgen_ty_1),
            "::",
            stringify!(compressionType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUmemAllocationProp_st__bindgen_ty_1>())).gpuDirectRDMACapable
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st__bindgen_ty_1),
            "::",
            stringify!(gpuDirectRDMACapable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUmemAllocationProp_st__bindgen_ty_1>())).usage as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st__bindgen_ty_1),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUmemAllocationProp_st__bindgen_ty_1>())).reserved as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_CUmemAllocationProp_st() {
    assert_eq!(
        ::std::mem::size_of::<CUmemAllocationProp_st>(),
        32usize,
        concat!("Size of: ", stringify!(CUmemAllocationProp_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUmemAllocationProp_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUmemAllocationProp_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUmemAllocationProp_st>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUmemAllocationProp_st>())).requestedHandleTypes as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st),
            "::",
            stringify!(requestedHandleTypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUmemAllocationProp_st>())).location as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUmemAllocationProp_st>())).win32HandleMetaData as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st),
            "::",
            stringify!(win32HandleMetaData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUmemAllocationProp_st>())).allocFlags as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st),
            "::",
            stringify!(allocFlags)
        )
    );
}
impl Default for CUmemAllocationProp_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUmemAllocationProp_v1 = CUmemAllocationProp_st;
pub type CUmemAllocationProp = CUmemAllocationProp_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUmemAccessDesc_st {
    pub location: CUmemLocation,
    pub flags: CUmemAccess_flags,
}
#[test]
fn bindgen_test_layout_CUmemAccessDesc_st() {
    assert_eq!(
        ::std::mem::size_of::<CUmemAccessDesc_st>(),
        12usize,
        concat!("Size of: ", stringify!(CUmemAccessDesc_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUmemAccessDesc_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUmemAccessDesc_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUmemAccessDesc_st>())).location as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAccessDesc_st),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUmemAccessDesc_st>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAccessDesc_st),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for CUmemAccessDesc_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUmemAccessDesc_v1 = CUmemAccessDesc_st;
pub type CUmemAccessDesc = CUmemAccessDesc_v1;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUgraphExecUpdateResult_enum {
    CU_GRAPH_EXEC_UPDATE_SUCCESS = 0,
    CU_GRAPH_EXEC_UPDATE_ERROR = 1,
    CU_GRAPH_EXEC_UPDATE_ERROR_TOPOLOGY_CHANGED = 2,
    CU_GRAPH_EXEC_UPDATE_ERROR_NODE_TYPE_CHANGED = 3,
    CU_GRAPH_EXEC_UPDATE_ERROR_FUNCTION_CHANGED = 4,
    CU_GRAPH_EXEC_UPDATE_ERROR_PARAMETERS_CHANGED = 5,
    CU_GRAPH_EXEC_UPDATE_ERROR_NOT_SUPPORTED = 6,
    CU_GRAPH_EXEC_UPDATE_ERROR_UNSUPPORTED_FUNCTION_CHANGE = 7,
}
pub use self::CUgraphExecUpdateResult_enum as CUgraphExecUpdateResult;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUmemPool_attribute_enum {
    CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES = 1,
    CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC = 2,
    CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES = 3,
    CU_MEMPOOL_ATTR_RELEASE_THRESHOLD = 4,
    CU_MEMPOOL_ATTR_RESERVED_MEM_CURRENT = 5,
    CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH = 6,
    CU_MEMPOOL_ATTR_USED_MEM_CURRENT = 7,
    CU_MEMPOOL_ATTR_USED_MEM_HIGH = 8,
}
pub use self::CUmemPool_attribute_enum as CUmemPool_attribute;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUmemPoolProps_st {
    pub allocType: CUmemAllocationType,
    pub handleTypes: CUmemAllocationHandleType,
    pub location: CUmemLocation,
    pub win32SecurityAttributes: *mut ::std::os::raw::c_void,
    pub reserved: [::std::os::raw::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_CUmemPoolProps_st() {
    assert_eq!(
        ::std::mem::size_of::<CUmemPoolProps_st>(),
        88usize,
        concat!("Size of: ", stringify!(CUmemPoolProps_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUmemPoolProps_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUmemPoolProps_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUmemPoolProps_st>())).allocType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemPoolProps_st),
            "::",
            stringify!(allocType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUmemPoolProps_st>())).handleTypes as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemPoolProps_st),
            "::",
            stringify!(handleTypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUmemPoolProps_st>())).location as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemPoolProps_st),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUmemPoolProps_st>())).win32SecurityAttributes as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemPoolProps_st),
            "::",
            stringify!(win32SecurityAttributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUmemPoolProps_st>())).reserved as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemPoolProps_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUmemPoolProps_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUmemPoolProps_v1 = CUmemPoolProps_st;
pub type CUmemPoolProps = CUmemPoolProps_v1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUmemPoolPtrExportData_st {
    pub reserved: [::std::os::raw::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_CUmemPoolPtrExportData_st() {
    assert_eq!(
        ::std::mem::size_of::<CUmemPoolPtrExportData_st>(),
        64usize,
        concat!("Size of: ", stringify!(CUmemPoolPtrExportData_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUmemPoolPtrExportData_st>(),
        1usize,
        concat!("Alignment of ", stringify!(CUmemPoolPtrExportData_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUmemPoolPtrExportData_st>())).reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemPoolPtrExportData_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUmemPoolPtrExportData_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUmemPoolPtrExportData_v1 = CUmemPoolPtrExportData_st;
pub type CUmemPoolPtrExportData = CUmemPoolPtrExportData_v1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_MEM_ALLOC_NODE_PARAMS_st {
    pub poolProps: CUmemPoolProps,
    pub accessDescs: *const CUmemAccessDesc,
    pub accessDescCount: usize,
    pub bytesize: usize,
    pub dptr: CUdeviceptr,
}
#[test]
fn bindgen_test_layout_CUDA_MEM_ALLOC_NODE_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_MEM_ALLOC_NODE_PARAMS_st>(),
        120usize,
        concat!("Size of: ", stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_MEM_ALLOC_NODE_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEM_ALLOC_NODE_PARAMS_st>())).poolProps as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_st),
            "::",
            stringify!(poolProps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEM_ALLOC_NODE_PARAMS_st>())).accessDescs as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_st),
            "::",
            stringify!(accessDescs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEM_ALLOC_NODE_PARAMS_st>())).accessDescCount as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_st),
            "::",
            stringify!(accessDescCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEM_ALLOC_NODE_PARAMS_st>())).bytesize as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_st),
            "::",
            stringify!(bytesize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CUDA_MEM_ALLOC_NODE_PARAMS_st>())).dptr as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_st),
            "::",
            stringify!(dptr)
        )
    );
}
impl Default for CUDA_MEM_ALLOC_NODE_PARAMS_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CUDA_MEM_ALLOC_NODE_PARAMS = CUDA_MEM_ALLOC_NODE_PARAMS_st;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUgraphMem_attribute_enum {
    CU_GRAPH_MEM_ATTR_USED_MEM_CURRENT = 0,
    CU_GRAPH_MEM_ATTR_USED_MEM_HIGH = 1,
    CU_GRAPH_MEM_ATTR_RESERVED_MEM_CURRENT = 2,
    CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH = 3,
}
pub use self::CUgraphMem_attribute_enum as CUgraphMem_attribute;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUflushGPUDirectRDMAWritesOptions_enum {
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_HOST = 1,
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_MEMOPS = 2,
}
pub use self::CUflushGPUDirectRDMAWritesOptions_enum as CUflushGPUDirectRDMAWritesOptions;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUGPUDirectRDMAWritesOrdering_enum {
    CU_GPU_DIRECT_RDMA_WRITES_ORDERING_NONE = 0,
    CU_GPU_DIRECT_RDMA_WRITES_ORDERING_OWNER = 100,
    CU_GPU_DIRECT_RDMA_WRITES_ORDERING_ALL_DEVICES = 200,
}
pub use self::CUGPUDirectRDMAWritesOrdering_enum as CUGPUDirectRDMAWritesOrdering;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUflushGPUDirectRDMAWritesScope_enum {
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_OWNER = 100,
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_ALL_DEVICES = 200,
}
pub use self::CUflushGPUDirectRDMAWritesScope_enum as CUflushGPUDirectRDMAWritesScope;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUflushGPUDirectRDMAWritesTarget_enum {
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TARGET_CURRENT_CTX = 0,
}
pub use self::CUflushGPUDirectRDMAWritesTarget_enum as CUflushGPUDirectRDMAWritesTarget;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUgraphDebugDot_flags_enum {
    CU_GRAPH_DEBUG_DOT_FLAGS_VERBOSE = 1,
    CU_GRAPH_DEBUG_DOT_FLAGS_RUNTIME_TYPES = 2,
    CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_PARAMS = 4,
    CU_GRAPH_DEBUG_DOT_FLAGS_MEMCPY_NODE_PARAMS = 8,
    CU_GRAPH_DEBUG_DOT_FLAGS_MEMSET_NODE_PARAMS = 16,
    CU_GRAPH_DEBUG_DOT_FLAGS_HOST_NODE_PARAMS = 32,
    CU_GRAPH_DEBUG_DOT_FLAGS_EVENT_NODE_PARAMS = 64,
    CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_SIGNAL_NODE_PARAMS = 128,
    CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_WAIT_NODE_PARAMS = 256,
    CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_ATTRIBUTES = 512,
    CU_GRAPH_DEBUG_DOT_FLAGS_HANDLES = 1024,
    CU_GRAPH_DEBUG_DOT_FLAGS_MEM_ALLOC_NODE_PARAMS = 2048,
    CU_GRAPH_DEBUG_DOT_FLAGS_MEM_FREE_NODE_PARAMS = 4096,
}
pub use self::CUgraphDebugDot_flags_enum as CUgraphDebugDot_flags;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUuserObject_flags_enum {
    CU_USER_OBJECT_NO_DESTRUCTOR_SYNC = 1,
}
pub use self::CUuserObject_flags_enum as CUuserObject_flags;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUuserObjectRetain_flags_enum {
    CU_GRAPH_USER_OBJECT_MOVE = 1,
}
pub use self::CUuserObjectRetain_flags_enum as CUuserObjectRetain_flags;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUgraphInstantiate_flags_enum {
    CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH = 1,
}
pub use self::CUgraphInstantiate_flags_enum as CUgraphInstantiate_flags;
extern "C" {
    pub fn cuGetErrorString(error: CUresult, pStr: *mut *const ::std::os::raw::c_char) -> CUresult;
}
extern "C" {
    pub fn cuGetErrorName(error: CUresult, pStr: *mut *const ::std::os::raw::c_char) -> CUresult;
}
extern "C" {
    pub fn cuInit(Flags: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    pub fn cuDriverGetVersion(driverVersion: *mut ::std::os::raw::c_int) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGet(device: *mut CUdevice, ordinal: ::std::os::raw::c_int) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetCount(count: *mut ::std::os::raw::c_int) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetName(
        name: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetUuid(uuid: *mut CUuuid, dev: CUdevice) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetUuid_v2(uuid: *mut CUuuid, dev: CUdevice) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetLuid(
        luid: *mut ::std::os::raw::c_char,
        deviceNodeMask: *mut ::std::os::raw::c_uint,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDeviceTotalMem_v2(bytes: *mut usize, dev: CUdevice) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetTexture1DLinearMaxWidth(
        maxWidthInElements: *mut usize,
        format: CUarray_format,
        numChannels: ::std::os::raw::c_uint,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetAttribute(
        pi: *mut ::std::os::raw::c_int,
        attrib: CUdevice_attribute,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetNvSciSyncAttributes(
        nvSciSyncAttrList: *mut ::std::os::raw::c_void,
        dev: CUdevice,
        flags: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDeviceSetMemPool(dev: CUdevice, pool: CUmemoryPool) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetMemPool(pool: *mut CUmemoryPool, dev: CUdevice) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetDefaultMemPool(pool_out: *mut CUmemoryPool, dev: CUdevice) -> CUresult;
}
extern "C" {
    pub fn cuFlushGPUDirectRDMAWrites(
        target: CUflushGPUDirectRDMAWritesTarget,
        scope: CUflushGPUDirectRDMAWritesScope,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetProperties(prop: *mut CUdevprop, dev: CUdevice) -> CUresult;
}
extern "C" {
    pub fn cuDeviceComputeCapability(
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDevicePrimaryCtxRetain(pctx: *mut CUcontext, dev: CUdevice) -> CUresult;
}
extern "C" {
    pub fn cuDevicePrimaryCtxRelease_v2(dev: CUdevice) -> CUresult;
}
extern "C" {
    pub fn cuDevicePrimaryCtxSetFlags_v2(dev: CUdevice, flags: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    pub fn cuDevicePrimaryCtxGetState(
        dev: CUdevice,
        flags: *mut ::std::os::raw::c_uint,
        active: *mut ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDevicePrimaryCtxReset_v2(dev: CUdevice) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetExecAffinitySupport(
        pi: *mut ::std::os::raw::c_int,
        type_: CUexecAffinityType,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuCtxCreate_v2(
        pctx: *mut CUcontext,
        flags: ::std::os::raw::c_uint,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuCtxCreate_v3(
        pctx: *mut CUcontext,
        paramsArray: *mut CUexecAffinityParam,
        numParams: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuCtxDestroy_v2(ctx: CUcontext) -> CUresult;
}
extern "C" {
    pub fn cuCtxPushCurrent_v2(ctx: CUcontext) -> CUresult;
}
extern "C" {
    pub fn cuCtxPopCurrent_v2(pctx: *mut CUcontext) -> CUresult;
}
extern "C" {
    pub fn cuCtxSetCurrent(ctx: CUcontext) -> CUresult;
}
extern "C" {
    pub fn cuCtxGetCurrent(pctx: *mut CUcontext) -> CUresult;
}
extern "C" {
    pub fn cuCtxGetDevice(device: *mut CUdevice) -> CUresult;
}
extern "C" {
    pub fn cuCtxGetFlags(flags: *mut ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    pub fn cuCtxSynchronize() -> CUresult;
}
extern "C" {
    pub fn cuCtxSetLimit(limit: CUlimit, value: usize) -> CUresult;
}
extern "C" {
    pub fn cuCtxGetLimit(pvalue: *mut usize, limit: CUlimit) -> CUresult;
}
extern "C" {
    pub fn cuCtxGetCacheConfig(pconfig: *mut CUfunc_cache) -> CUresult;
}
extern "C" {
    pub fn cuCtxSetCacheConfig(config: CUfunc_cache) -> CUresult;
}
extern "C" {
    pub fn cuCtxGetSharedMemConfig(pConfig: *mut CUsharedconfig) -> CUresult;
}
extern "C" {
    pub fn cuCtxSetSharedMemConfig(config: CUsharedconfig) -> CUresult;
}
extern "C" {
    pub fn cuCtxGetApiVersion(ctx: CUcontext, version: *mut ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    pub fn cuCtxGetStreamPriorityRange(
        leastPriority: *mut ::std::os::raw::c_int,
        greatestPriority: *mut ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    pub fn cuCtxResetPersistingL2Cache() -> CUresult;
}
extern "C" {
    pub fn cuCtxGetExecAffinity(
        pExecAffinity: *mut CUexecAffinityParam,
        type_: CUexecAffinityType,
    ) -> CUresult;
}
extern "C" {
    pub fn cuCtxAttach(pctx: *mut CUcontext, flags: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    pub fn cuCtxDetach(ctx: CUcontext) -> CUresult;
}
extern "C" {
    pub fn cuModuleLoad(module: *mut CUmodule, fname: *const ::std::os::raw::c_char) -> CUresult;
}
extern "C" {
    pub fn cuModuleLoadData(
        module: *mut CUmodule,
        image: *const ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    pub fn cuModuleLoadDataEx(
        module: *mut CUmodule,
        image: *const ::std::os::raw::c_void,
        numOptions: ::std::os::raw::c_uint,
        options: *mut CUjit_option,
        optionValues: *mut *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    pub fn cuModuleLoadFatBinary(
        module: *mut CUmodule,
        fatCubin: *const ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    pub fn cuModuleUnload(hmod: CUmodule) -> CUresult;
}
extern "C" {
    pub fn cuModuleGetFunction(
        hfunc: *mut CUfunction,
        hmod: CUmodule,
        name: *const ::std::os::raw::c_char,
    ) -> CUresult;
}
extern "C" {
    pub fn cuModuleGetGlobal_v2(
        dptr: *mut CUdeviceptr,
        bytes: *mut usize,
        hmod: CUmodule,
        name: *const ::std::os::raw::c_char,
    ) -> CUresult;
}
extern "C" {
    pub fn cuModuleGetTexRef(
        pTexRef: *mut CUtexref,
        hmod: CUmodule,
        name: *const ::std::os::raw::c_char,
    ) -> CUresult;
}
extern "C" {
    pub fn cuModuleGetSurfRef(
        pSurfRef: *mut CUsurfref,
        hmod: CUmodule,
        name: *const ::std::os::raw::c_char,
    ) -> CUresult;
}
extern "C" {
    pub fn cuLinkCreate_v2(
        numOptions: ::std::os::raw::c_uint,
        options: *mut CUjit_option,
        optionValues: *mut *mut ::std::os::raw::c_void,
        stateOut: *mut CUlinkState,
    ) -> CUresult;
}
extern "C" {
    pub fn cuLinkAddData_v2(
        state: CUlinkState,
        type_: CUjitInputType,
        data: *mut ::std::os::raw::c_void,
        size: usize,
        name: *const ::std::os::raw::c_char,
        numOptions: ::std::os::raw::c_uint,
        options: *mut CUjit_option,
        optionValues: *mut *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    pub fn cuLinkAddFile_v2(
        state: CUlinkState,
        type_: CUjitInputType,
        path: *const ::std::os::raw::c_char,
        numOptions: ::std::os::raw::c_uint,
        options: *mut CUjit_option,
        optionValues: *mut *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    pub fn cuLinkComplete(
        state: CUlinkState,
        cubinOut: *mut *mut ::std::os::raw::c_void,
        sizeOut: *mut usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuLinkDestroy(state: CUlinkState) -> CUresult;
}
extern "C" {
    pub fn cuMemGetInfo_v2(free: *mut usize, total: *mut usize) -> CUresult;
}
extern "C" {
    pub fn cuMemAlloc_v2(dptr: *mut CUdeviceptr, bytesize: usize) -> CUresult;
}
extern "C" {
    pub fn cuMemAllocPitch_v2(
        dptr: *mut CUdeviceptr,
        pPitch: *mut usize,
        WidthInBytes: usize,
        Height: usize,
        ElementSizeBytes: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemFree_v2(dptr: CUdeviceptr) -> CUresult;
}
extern "C" {
    pub fn cuMemGetAddressRange_v2(
        pbase: *mut CUdeviceptr,
        psize: *mut usize,
        dptr: CUdeviceptr,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemAllocHost_v2(pp: *mut *mut ::std::os::raw::c_void, bytesize: usize) -> CUresult;
}
extern "C" {
    pub fn cuMemFreeHost(p: *mut ::std::os::raw::c_void) -> CUresult;
}
extern "C" {
    pub fn cuMemHostAlloc(
        pp: *mut *mut ::std::os::raw::c_void,
        bytesize: usize,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemHostGetDevicePointer_v2(
        pdptr: *mut CUdeviceptr,
        p: *mut ::std::os::raw::c_void,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemHostGetFlags(
        pFlags: *mut ::std::os::raw::c_uint,
        p: *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemAllocManaged(
        dptr: *mut CUdeviceptr,
        bytesize: usize,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetByPCIBusId(
        dev: *mut CUdevice,
        pciBusId: *const ::std::os::raw::c_char,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetPCIBusId(
        pciBusId: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuIpcGetEventHandle(pHandle: *mut CUipcEventHandle, event: CUevent) -> CUresult;
}
extern "C" {
    pub fn cuIpcOpenEventHandle(phEvent: *mut CUevent, handle: CUipcEventHandle) -> CUresult;
}
extern "C" {
    pub fn cuIpcGetMemHandle(pHandle: *mut CUipcMemHandle, dptr: CUdeviceptr) -> CUresult;
}
extern "C" {
    pub fn cuIpcOpenMemHandle_v2(
        pdptr: *mut CUdeviceptr,
        handle: CUipcMemHandle,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuIpcCloseMemHandle(dptr: CUdeviceptr) -> CUresult;
}
extern "C" {
    pub fn cuMemHostRegister_v2(
        p: *mut ::std::os::raw::c_void,
        bytesize: usize,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemHostUnregister(p: *mut ::std::os::raw::c_void) -> CUresult;
}
extern "C" {
    pub fn cuMemcpy(dst: CUdeviceptr, src: CUdeviceptr, ByteCount: usize) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyPeer(
        dstDevice: CUdeviceptr,
        dstContext: CUcontext,
        srcDevice: CUdeviceptr,
        srcContext: CUcontext,
        ByteCount: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyHtoD_v2(
        dstDevice: CUdeviceptr,
        srcHost: *const ::std::os::raw::c_void,
        ByteCount: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyDtoH_v2(
        dstHost: *mut ::std::os::raw::c_void,
        srcDevice: CUdeviceptr,
        ByteCount: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyDtoD_v2(
        dstDevice: CUdeviceptr,
        srcDevice: CUdeviceptr,
        ByteCount: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyDtoA_v2(
        dstArray: CUarray,
        dstOffset: usize,
        srcDevice: CUdeviceptr,
        ByteCount: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyAtoD_v2(
        dstDevice: CUdeviceptr,
        srcArray: CUarray,
        srcOffset: usize,
        ByteCount: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyHtoA_v2(
        dstArray: CUarray,
        dstOffset: usize,
        srcHost: *const ::std::os::raw::c_void,
        ByteCount: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyAtoH_v2(
        dstHost: *mut ::std::os::raw::c_void,
        srcArray: CUarray,
        srcOffset: usize,
        ByteCount: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyAtoA_v2(
        dstArray: CUarray,
        dstOffset: usize,
        srcArray: CUarray,
        srcOffset: usize,
        ByteCount: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpy2D_v2(pCopy: *const CUDA_MEMCPY2D) -> CUresult;
}
extern "C" {
    pub fn cuMemcpy2DUnaligned_v2(pCopy: *const CUDA_MEMCPY2D) -> CUresult;
}
extern "C" {
    pub fn cuMemcpy3D_v2(pCopy: *const CUDA_MEMCPY3D) -> CUresult;
}
extern "C" {
    pub fn cuMemcpy3DPeer(pCopy: *const CUDA_MEMCPY3D_PEER) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyAsync(
        dst: CUdeviceptr,
        src: CUdeviceptr,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyPeerAsync(
        dstDevice: CUdeviceptr,
        dstContext: CUcontext,
        srcDevice: CUdeviceptr,
        srcContext: CUcontext,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyHtoDAsync_v2(
        dstDevice: CUdeviceptr,
        srcHost: *const ::std::os::raw::c_void,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyDtoHAsync_v2(
        dstHost: *mut ::std::os::raw::c_void,
        srcDevice: CUdeviceptr,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyDtoDAsync_v2(
        dstDevice: CUdeviceptr,
        srcDevice: CUdeviceptr,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyHtoAAsync_v2(
        dstArray: CUarray,
        dstOffset: usize,
        srcHost: *const ::std::os::raw::c_void,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyAtoHAsync_v2(
        dstHost: *mut ::std::os::raw::c_void,
        srcArray: CUarray,
        srcOffset: usize,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpy2DAsync_v2(pCopy: *const CUDA_MEMCPY2D, hStream: CUstream) -> CUresult;
}
extern "C" {
    pub fn cuMemcpy3DAsync_v2(pCopy: *const CUDA_MEMCPY3D, hStream: CUstream) -> CUresult;
}
extern "C" {
    pub fn cuMemcpy3DPeerAsync(pCopy: *const CUDA_MEMCPY3D_PEER, hStream: CUstream) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD8_v2(dstDevice: CUdeviceptr, uc: ::std::os::raw::c_uchar, N: usize)
        -> CUresult;
}
extern "C" {
    pub fn cuMemsetD16_v2(
        dstDevice: CUdeviceptr,
        us: ::std::os::raw::c_ushort,
        N: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD32_v2(dstDevice: CUdeviceptr, ui: ::std::os::raw::c_uint, N: usize)
        -> CUresult;
}
extern "C" {
    pub fn cuMemsetD2D8_v2(
        dstDevice: CUdeviceptr,
        dstPitch: usize,
        uc: ::std::os::raw::c_uchar,
        Width: usize,
        Height: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD2D16_v2(
        dstDevice: CUdeviceptr,
        dstPitch: usize,
        us: ::std::os::raw::c_ushort,
        Width: usize,
        Height: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD2D32_v2(
        dstDevice: CUdeviceptr,
        dstPitch: usize,
        ui: ::std::os::raw::c_uint,
        Width: usize,
        Height: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD8Async(
        dstDevice: CUdeviceptr,
        uc: ::std::os::raw::c_uchar,
        N: usize,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD16Async(
        dstDevice: CUdeviceptr,
        us: ::std::os::raw::c_ushort,
        N: usize,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD32Async(
        dstDevice: CUdeviceptr,
        ui: ::std::os::raw::c_uint,
        N: usize,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD2D8Async(
        dstDevice: CUdeviceptr,
        dstPitch: usize,
        uc: ::std::os::raw::c_uchar,
        Width: usize,
        Height: usize,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD2D16Async(
        dstDevice: CUdeviceptr,
        dstPitch: usize,
        us: ::std::os::raw::c_ushort,
        Width: usize,
        Height: usize,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD2D32Async(
        dstDevice: CUdeviceptr,
        dstPitch: usize,
        ui: ::std::os::raw::c_uint,
        Width: usize,
        Height: usize,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuArrayCreate_v2(
        pHandle: *mut CUarray,
        pAllocateArray: *const CUDA_ARRAY_DESCRIPTOR,
    ) -> CUresult;
}
extern "C" {
    pub fn cuArrayGetDescriptor_v2(
        pArrayDescriptor: *mut CUDA_ARRAY_DESCRIPTOR,
        hArray: CUarray,
    ) -> CUresult;
}
extern "C" {
    pub fn cuArrayGetSparseProperties(
        sparseProperties: *mut CUDA_ARRAY_SPARSE_PROPERTIES,
        array: CUarray,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMipmappedArrayGetSparseProperties(
        sparseProperties: *mut CUDA_ARRAY_SPARSE_PROPERTIES,
        mipmap: CUmipmappedArray,
    ) -> CUresult;
}
extern "C" {
    pub fn cuArrayGetPlane(
        pPlaneArray: *mut CUarray,
        hArray: CUarray,
        planeIdx: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuArrayDestroy(hArray: CUarray) -> CUresult;
}
extern "C" {
    pub fn cuArray3DCreate_v2(
        pHandle: *mut CUarray,
        pAllocateArray: *const CUDA_ARRAY3D_DESCRIPTOR,
    ) -> CUresult;
}
extern "C" {
    pub fn cuArray3DGetDescriptor_v2(
        pArrayDescriptor: *mut CUDA_ARRAY3D_DESCRIPTOR,
        hArray: CUarray,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMipmappedArrayCreate(
        pHandle: *mut CUmipmappedArray,
        pMipmappedArrayDesc: *const CUDA_ARRAY3D_DESCRIPTOR,
        numMipmapLevels: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMipmappedArrayGetLevel(
        pLevelArray: *mut CUarray,
        hMipmappedArray: CUmipmappedArray,
        level: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMipmappedArrayDestroy(hMipmappedArray: CUmipmappedArray) -> CUresult;
}
extern "C" {
    pub fn cuMemAddressReserve(
        ptr: *mut CUdeviceptr,
        size: usize,
        alignment: usize,
        addr: CUdeviceptr,
        flags: ::std::os::raw::c_ulonglong,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemAddressFree(ptr: CUdeviceptr, size: usize) -> CUresult;
}
extern "C" {
    pub fn cuMemCreate(
        handle: *mut CUmemGenericAllocationHandle,
        size: usize,
        prop: *const CUmemAllocationProp,
        flags: ::std::os::raw::c_ulonglong,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemRelease(handle: CUmemGenericAllocationHandle) -> CUresult;
}
extern "C" {
    pub fn cuMemMap(
        ptr: CUdeviceptr,
        size: usize,
        offset: usize,
        handle: CUmemGenericAllocationHandle,
        flags: ::std::os::raw::c_ulonglong,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemMapArrayAsync(
        mapInfoList: *mut CUarrayMapInfo,
        count: ::std::os::raw::c_uint,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemUnmap(ptr: CUdeviceptr, size: usize) -> CUresult;
}
extern "C" {
    pub fn cuMemSetAccess(
        ptr: CUdeviceptr,
        size: usize,
        desc: *const CUmemAccessDesc,
        count: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemGetAccess(
        flags: *mut ::std::os::raw::c_ulonglong,
        location: *const CUmemLocation,
        ptr: CUdeviceptr,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemExportToShareableHandle(
        shareableHandle: *mut ::std::os::raw::c_void,
        handle: CUmemGenericAllocationHandle,
        handleType: CUmemAllocationHandleType,
        flags: ::std::os::raw::c_ulonglong,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemImportFromShareableHandle(
        handle: *mut CUmemGenericAllocationHandle,
        osHandle: *mut ::std::os::raw::c_void,
        shHandleType: CUmemAllocationHandleType,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemGetAllocationGranularity(
        granularity: *mut usize,
        prop: *const CUmemAllocationProp,
        option: CUmemAllocationGranularity_flags,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemGetAllocationPropertiesFromHandle(
        prop: *mut CUmemAllocationProp,
        handle: CUmemGenericAllocationHandle,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemRetainAllocationHandle(
        handle: *mut CUmemGenericAllocationHandle,
        addr: *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemFreeAsync(dptr: CUdeviceptr, hStream: CUstream) -> CUresult;
}
extern "C" {
    pub fn cuMemAllocAsync(dptr: *mut CUdeviceptr, bytesize: usize, hStream: CUstream) -> CUresult;
}
extern "C" {
    pub fn cuMemPoolTrimTo(pool: CUmemoryPool, minBytesToKeep: usize) -> CUresult;
}
extern "C" {
    pub fn cuMemPoolSetAttribute(
        pool: CUmemoryPool,
        attr: CUmemPool_attribute,
        value: *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemPoolGetAttribute(
        pool: CUmemoryPool,
        attr: CUmemPool_attribute,
        value: *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemPoolSetAccess(
        pool: CUmemoryPool,
        map: *const CUmemAccessDesc,
        count: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemPoolGetAccess(
        flags: *mut CUmemAccess_flags,
        memPool: CUmemoryPool,
        location: *mut CUmemLocation,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemPoolCreate(pool: *mut CUmemoryPool, poolProps: *const CUmemPoolProps) -> CUresult;
}
extern "C" {
    pub fn cuMemPoolDestroy(pool: CUmemoryPool) -> CUresult;
}
extern "C" {
    pub fn cuMemAllocFromPoolAsync(
        dptr: *mut CUdeviceptr,
        bytesize: usize,
        pool: CUmemoryPool,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemPoolExportToShareableHandle(
        handle_out: *mut ::std::os::raw::c_void,
        pool: CUmemoryPool,
        handleType: CUmemAllocationHandleType,
        flags: ::std::os::raw::c_ulonglong,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemPoolImportFromShareableHandle(
        pool_out: *mut CUmemoryPool,
        handle: *mut ::std::os::raw::c_void,
        handleType: CUmemAllocationHandleType,
        flags: ::std::os::raw::c_ulonglong,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemPoolExportPointer(
        shareData_out: *mut CUmemPoolPtrExportData,
        ptr: CUdeviceptr,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemPoolImportPointer(
        ptr_out: *mut CUdeviceptr,
        pool: CUmemoryPool,
        shareData: *mut CUmemPoolPtrExportData,
    ) -> CUresult;
}
extern "C" {
    pub fn cuPointerGetAttribute(
        data: *mut ::std::os::raw::c_void,
        attribute: CUpointer_attribute,
        ptr: CUdeviceptr,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemPrefetchAsync(
        devPtr: CUdeviceptr,
        count: usize,
        dstDevice: CUdevice,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemAdvise(
        devPtr: CUdeviceptr,
        count: usize,
        advice: CUmem_advise,
        device: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemRangeGetAttribute(
        data: *mut ::std::os::raw::c_void,
        dataSize: usize,
        attribute: CUmem_range_attribute,
        devPtr: CUdeviceptr,
        count: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemRangeGetAttributes(
        data: *mut *mut ::std::os::raw::c_void,
        dataSizes: *mut usize,
        attributes: *mut CUmem_range_attribute,
        numAttributes: usize,
        devPtr: CUdeviceptr,
        count: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuPointerSetAttribute(
        value: *const ::std::os::raw::c_void,
        attribute: CUpointer_attribute,
        ptr: CUdeviceptr,
    ) -> CUresult;
}
extern "C" {
    pub fn cuPointerGetAttributes(
        numAttributes: ::std::os::raw::c_uint,
        attributes: *mut CUpointer_attribute,
        data: *mut *mut ::std::os::raw::c_void,
        ptr: CUdeviceptr,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamCreate(phStream: *mut CUstream, Flags: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    pub fn cuStreamCreateWithPriority(
        phStream: *mut CUstream,
        flags: ::std::os::raw::c_uint,
        priority: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamGetPriority(hStream: CUstream, priority: *mut ::std::os::raw::c_int)
        -> CUresult;
}
extern "C" {
    pub fn cuStreamGetFlags(hStream: CUstream, flags: *mut ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    pub fn cuStreamGetCtx(hStream: CUstream, pctx: *mut CUcontext) -> CUresult;
}
extern "C" {
    pub fn cuStreamWaitEvent(
        hStream: CUstream,
        hEvent: CUevent,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamAddCallback(
        hStream: CUstream,
        callback: CUstreamCallback,
        userData: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamBeginCapture_v2(hStream: CUstream, mode: CUstreamCaptureMode) -> CUresult;
}
extern "C" {
    pub fn cuThreadExchangeStreamCaptureMode(mode: *mut CUstreamCaptureMode) -> CUresult;
}
extern "C" {
    pub fn cuStreamEndCapture(hStream: CUstream, phGraph: *mut CUgraph) -> CUresult;
}
extern "C" {
    pub fn cuStreamIsCapturing(
        hStream: CUstream,
        captureStatus: *mut CUstreamCaptureStatus,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamGetCaptureInfo(
        hStream: CUstream,
        captureStatus_out: *mut CUstreamCaptureStatus,
        id_out: *mut cuuint64_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamGetCaptureInfo_v2(
        hStream: CUstream,
        captureStatus_out: *mut CUstreamCaptureStatus,
        id_out: *mut cuuint64_t,
        graph_out: *mut CUgraph,
        dependencies_out: *mut *const CUgraphNode,
        numDependencies_out: *mut usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamUpdateCaptureDependencies(
        hStream: CUstream,
        dependencies: *mut CUgraphNode,
        numDependencies: usize,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamAttachMemAsync(
        hStream: CUstream,
        dptr: CUdeviceptr,
        length: usize,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamQuery(hStream: CUstream) -> CUresult;
}
extern "C" {
    pub fn cuStreamSynchronize(hStream: CUstream) -> CUresult;
}
extern "C" {
    pub fn cuStreamDestroy_v2(hStream: CUstream) -> CUresult;
}
extern "C" {
    pub fn cuStreamCopyAttributes(dst: CUstream, src: CUstream) -> CUresult;
}
extern "C" {
    pub fn cuStreamGetAttribute(
        hStream: CUstream,
        attr: CUstreamAttrID,
        value_out: *mut CUstreamAttrValue,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamSetAttribute(
        hStream: CUstream,
        attr: CUstreamAttrID,
        value: *const CUstreamAttrValue,
    ) -> CUresult;
}
extern "C" {
    pub fn cuEventCreate(phEvent: *mut CUevent, Flags: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    pub fn cuEventRecord(hEvent: CUevent, hStream: CUstream) -> CUresult;
}
extern "C" {
    pub fn cuEventRecordWithFlags(
        hEvent: CUevent,
        hStream: CUstream,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuEventQuery(hEvent: CUevent) -> CUresult;
}
extern "C" {
    pub fn cuEventSynchronize(hEvent: CUevent) -> CUresult;
}
extern "C" {
    pub fn cuEventDestroy_v2(hEvent: CUevent) -> CUresult;
}
extern "C" {
    pub fn cuEventElapsedTime(pMilliseconds: *mut f32, hStart: CUevent, hEnd: CUevent) -> CUresult;
}
extern "C" {
    pub fn cuImportExternalMemory(
        extMem_out: *mut CUexternalMemory,
        memHandleDesc: *const CUDA_EXTERNAL_MEMORY_HANDLE_DESC,
    ) -> CUresult;
}
extern "C" {
    pub fn cuExternalMemoryGetMappedBuffer(
        devPtr: *mut CUdeviceptr,
        extMem: CUexternalMemory,
        bufferDesc: *const CUDA_EXTERNAL_MEMORY_BUFFER_DESC,
    ) -> CUresult;
}
extern "C" {
    pub fn cuExternalMemoryGetMappedMipmappedArray(
        mipmap: *mut CUmipmappedArray,
        extMem: CUexternalMemory,
        mipmapDesc: *const CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDestroyExternalMemory(extMem: CUexternalMemory) -> CUresult;
}
extern "C" {
    pub fn cuImportExternalSemaphore(
        extSem_out: *mut CUexternalSemaphore,
        semHandleDesc: *const CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC,
    ) -> CUresult;
}
extern "C" {
    pub fn cuSignalExternalSemaphoresAsync(
        extSemArray: *const CUexternalSemaphore,
        paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS,
        numExtSems: ::std::os::raw::c_uint,
        stream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuWaitExternalSemaphoresAsync(
        extSemArray: *const CUexternalSemaphore,
        paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS,
        numExtSems: ::std::os::raw::c_uint,
        stream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDestroyExternalSemaphore(extSem: CUexternalSemaphore) -> CUresult;
}
extern "C" {
    pub fn cuStreamWaitValue32(
        stream: CUstream,
        addr: CUdeviceptr,
        value: cuuint32_t,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamWaitValue64(
        stream: CUstream,
        addr: CUdeviceptr,
        value: cuuint64_t,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamWriteValue32(
        stream: CUstream,
        addr: CUdeviceptr,
        value: cuuint32_t,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamWriteValue64(
        stream: CUstream,
        addr: CUdeviceptr,
        value: cuuint64_t,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamBatchMemOp(
        stream: CUstream,
        count: ::std::os::raw::c_uint,
        paramArray: *mut CUstreamBatchMemOpParams,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuFuncGetAttribute(
        pi: *mut ::std::os::raw::c_int,
        attrib: CUfunction_attribute,
        hfunc: CUfunction,
    ) -> CUresult;
}
extern "C" {
    pub fn cuFuncSetAttribute(
        hfunc: CUfunction,
        attrib: CUfunction_attribute,
        value: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    pub fn cuFuncSetCacheConfig(hfunc: CUfunction, config: CUfunc_cache) -> CUresult;
}
extern "C" {
    pub fn cuFuncSetSharedMemConfig(hfunc: CUfunction, config: CUsharedconfig) -> CUresult;
}
extern "C" {
    pub fn cuFuncGetModule(hmod: *mut CUmodule, hfunc: CUfunction) -> CUresult;
}
extern "C" {
    pub fn cuLaunchKernel(
        f: CUfunction,
        gridDimX: ::std::os::raw::c_uint,
        gridDimY: ::std::os::raw::c_uint,
        gridDimZ: ::std::os::raw::c_uint,
        blockDimX: ::std::os::raw::c_uint,
        blockDimY: ::std::os::raw::c_uint,
        blockDimZ: ::std::os::raw::c_uint,
        sharedMemBytes: ::std::os::raw::c_uint,
        hStream: CUstream,
        kernelParams: *mut *mut ::std::os::raw::c_void,
        extra: *mut *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    pub fn cuLaunchCooperativeKernel(
        f: CUfunction,
        gridDimX: ::std::os::raw::c_uint,
        gridDimY: ::std::os::raw::c_uint,
        gridDimZ: ::std::os::raw::c_uint,
        blockDimX: ::std::os::raw::c_uint,
        blockDimY: ::std::os::raw::c_uint,
        blockDimZ: ::std::os::raw::c_uint,
        sharedMemBytes: ::std::os::raw::c_uint,
        hStream: CUstream,
        kernelParams: *mut *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    pub fn cuLaunchCooperativeKernelMultiDevice(
        launchParamsList: *mut CUDA_LAUNCH_PARAMS,
        numDevices: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuLaunchHostFunc(
        hStream: CUstream,
        fn_: CUhostFn,
        userData: *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    pub fn cuFuncSetBlockShape(
        hfunc: CUfunction,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    pub fn cuFuncSetSharedSize(hfunc: CUfunction, bytes: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    pub fn cuParamSetSize(hfunc: CUfunction, numbytes: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    pub fn cuParamSeti(
        hfunc: CUfunction,
        offset: ::std::os::raw::c_int,
        value: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuParamSetf(hfunc: CUfunction, offset: ::std::os::raw::c_int, value: f32) -> CUresult;
}
extern "C" {
    pub fn cuParamSetv(
        hfunc: CUfunction,
        offset: ::std::os::raw::c_int,
        ptr: *mut ::std::os::raw::c_void,
        numbytes: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuLaunch(f: CUfunction) -> CUresult;
}
extern "C" {
    pub fn cuLaunchGrid(
        f: CUfunction,
        grid_width: ::std::os::raw::c_int,
        grid_height: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    pub fn cuLaunchGridAsync(
        f: CUfunction,
        grid_width: ::std::os::raw::c_int,
        grid_height: ::std::os::raw::c_int,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuParamSetTexRef(
        hfunc: CUfunction,
        texunit: ::std::os::raw::c_int,
        hTexRef: CUtexref,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphCreate(phGraph: *mut CUgraph, flags: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    pub fn cuGraphAddKernelNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        nodeParams: *const CUDA_KERNEL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphKernelNodeGetParams(
        hNode: CUgraphNode,
        nodeParams: *mut CUDA_KERNEL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphKernelNodeSetParams(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_KERNEL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphAddMemcpyNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        copyParams: *const CUDA_MEMCPY3D,
        ctx: CUcontext,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphMemcpyNodeGetParams(
        hNode: CUgraphNode,
        nodeParams: *mut CUDA_MEMCPY3D,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphMemcpyNodeSetParams(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_MEMCPY3D,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphAddMemsetNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        memsetParams: *const CUDA_MEMSET_NODE_PARAMS,
        ctx: CUcontext,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphMemsetNodeGetParams(
        hNode: CUgraphNode,
        nodeParams: *mut CUDA_MEMSET_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphMemsetNodeSetParams(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_MEMSET_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphAddHostNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        nodeParams: *const CUDA_HOST_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphHostNodeGetParams(
        hNode: CUgraphNode,
        nodeParams: *mut CUDA_HOST_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphHostNodeSetParams(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_HOST_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphAddChildGraphNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        childGraph: CUgraph,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphChildGraphNodeGetGraph(hNode: CUgraphNode, phGraph: *mut CUgraph) -> CUresult;
}
extern "C" {
    pub fn cuGraphAddEmptyNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphAddEventRecordNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        event: CUevent,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphEventRecordNodeGetEvent(hNode: CUgraphNode, event_out: *mut CUevent) -> CUresult;
}
extern "C" {
    pub fn cuGraphEventRecordNodeSetEvent(hNode: CUgraphNode, event: CUevent) -> CUresult;
}
extern "C" {
    pub fn cuGraphAddEventWaitNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        event: CUevent,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphEventWaitNodeGetEvent(hNode: CUgraphNode, event_out: *mut CUevent) -> CUresult;
}
extern "C" {
    pub fn cuGraphEventWaitNodeSetEvent(hNode: CUgraphNode, event: CUevent) -> CUresult;
}
extern "C" {
    pub fn cuGraphAddExternalSemaphoresSignalNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        nodeParams: *const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphExternalSemaphoresSignalNodeGetParams(
        hNode: CUgraphNode,
        params_out: *mut CUDA_EXT_SEM_SIGNAL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphExternalSemaphoresSignalNodeSetParams(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphAddExternalSemaphoresWaitNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        nodeParams: *const CUDA_EXT_SEM_WAIT_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphExternalSemaphoresWaitNodeGetParams(
        hNode: CUgraphNode,
        params_out: *mut CUDA_EXT_SEM_WAIT_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphExternalSemaphoresWaitNodeSetParams(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_EXT_SEM_WAIT_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphAddMemAllocNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        nodeParams: *mut CUDA_MEM_ALLOC_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphMemAllocNodeGetParams(
        hNode: CUgraphNode,
        params_out: *mut CUDA_MEM_ALLOC_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphAddMemFreeNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        dptr: CUdeviceptr,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphMemFreeNodeGetParams(hNode: CUgraphNode, dptr_out: *mut CUdeviceptr) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGraphMemTrim(device: CUdevice) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetGraphMemAttribute(
        device: CUdevice,
        attr: CUgraphMem_attribute,
        value: *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDeviceSetGraphMemAttribute(
        device: CUdevice,
        attr: CUgraphMem_attribute,
        value: *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphClone(phGraphClone: *mut CUgraph, originalGraph: CUgraph) -> CUresult;
}
extern "C" {
    pub fn cuGraphNodeFindInClone(
        phNode: *mut CUgraphNode,
        hOriginalNode: CUgraphNode,
        hClonedGraph: CUgraph,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphNodeGetType(hNode: CUgraphNode, type_: *mut CUgraphNodeType) -> CUresult;
}
extern "C" {
    pub fn cuGraphGetNodes(
        hGraph: CUgraph,
        nodes: *mut CUgraphNode,
        numNodes: *mut usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphGetRootNodes(
        hGraph: CUgraph,
        rootNodes: *mut CUgraphNode,
        numRootNodes: *mut usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphGetEdges(
        hGraph: CUgraph,
        from: *mut CUgraphNode,
        to: *mut CUgraphNode,
        numEdges: *mut usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphNodeGetDependencies(
        hNode: CUgraphNode,
        dependencies: *mut CUgraphNode,
        numDependencies: *mut usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphNodeGetDependentNodes(
        hNode: CUgraphNode,
        dependentNodes: *mut CUgraphNode,
        numDependentNodes: *mut usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphAddDependencies(
        hGraph: CUgraph,
        from: *const CUgraphNode,
        to: *const CUgraphNode,
        numDependencies: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphRemoveDependencies(
        hGraph: CUgraph,
        from: *const CUgraphNode,
        to: *const CUgraphNode,
        numDependencies: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphDestroyNode(hNode: CUgraphNode) -> CUresult;
}
extern "C" {
    pub fn cuGraphInstantiate_v2(
        phGraphExec: *mut CUgraphExec,
        hGraph: CUgraph,
        phErrorNode: *mut CUgraphNode,
        logBuffer: *mut ::std::os::raw::c_char,
        bufferSize: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphInstantiateWithFlags(
        phGraphExec: *mut CUgraphExec,
        hGraph: CUgraph,
        flags: ::std::os::raw::c_ulonglong,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphExecKernelNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_KERNEL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphExecMemcpyNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        copyParams: *const CUDA_MEMCPY3D,
        ctx: CUcontext,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphExecMemsetNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        memsetParams: *const CUDA_MEMSET_NODE_PARAMS,
        ctx: CUcontext,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphExecHostNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_HOST_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphExecChildGraphNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        childGraph: CUgraph,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphExecEventRecordNodeSetEvent(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        event: CUevent,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphExecEventWaitNodeSetEvent(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        event: CUevent,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphExecExternalSemaphoresSignalNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphExecExternalSemaphoresWaitNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_EXT_SEM_WAIT_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphUpload(hGraphExec: CUgraphExec, hStream: CUstream) -> CUresult;
}
extern "C" {
    pub fn cuGraphLaunch(hGraphExec: CUgraphExec, hStream: CUstream) -> CUresult;
}
extern "C" {
    pub fn cuGraphExecDestroy(hGraphExec: CUgraphExec) -> CUresult;
}
extern "C" {
    pub fn cuGraphDestroy(hGraph: CUgraph) -> CUresult;
}
extern "C" {
    pub fn cuGraphExecUpdate(
        hGraphExec: CUgraphExec,
        hGraph: CUgraph,
        hErrorNode_out: *mut CUgraphNode,
        updateResult_out: *mut CUgraphExecUpdateResult,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphKernelNodeCopyAttributes(dst: CUgraphNode, src: CUgraphNode) -> CUresult;
}
extern "C" {
    pub fn cuGraphKernelNodeGetAttribute(
        hNode: CUgraphNode,
        attr: CUkernelNodeAttrID,
        value_out: *mut CUkernelNodeAttrValue,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphKernelNodeSetAttribute(
        hNode: CUgraphNode,
        attr: CUkernelNodeAttrID,
        value: *const CUkernelNodeAttrValue,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphDebugDotPrint(
        hGraph: CUgraph,
        path: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuUserObjectCreate(
        object_out: *mut CUuserObject,
        ptr: *mut ::std::os::raw::c_void,
        destroy: CUhostFn,
        initialRefcount: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuUserObjectRetain(object: CUuserObject, count: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    pub fn cuUserObjectRelease(object: CUuserObject, count: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    pub fn cuGraphRetainUserObject(
        graph: CUgraph,
        object: CUuserObject,
        count: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphReleaseUserObject(
        graph: CUgraph,
        object: CUuserObject,
        count: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuOccupancyMaxActiveBlocksPerMultiprocessor(
        numBlocks: *mut ::std::os::raw::c_int,
        func: CUfunction,
        blockSize: ::std::os::raw::c_int,
        dynamicSMemSize: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
        numBlocks: *mut ::std::os::raw::c_int,
        func: CUfunction,
        blockSize: ::std::os::raw::c_int,
        dynamicSMemSize: usize,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuOccupancyMaxPotentialBlockSize(
        minGridSize: *mut ::std::os::raw::c_int,
        blockSize: *mut ::std::os::raw::c_int,
        func: CUfunction,
        blockSizeToDynamicSMemSize: CUoccupancyB2DSize,
        dynamicSMemSize: usize,
        blockSizeLimit: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    pub fn cuOccupancyMaxPotentialBlockSizeWithFlags(
        minGridSize: *mut ::std::os::raw::c_int,
        blockSize: *mut ::std::os::raw::c_int,
        func: CUfunction,
        blockSizeToDynamicSMemSize: CUoccupancyB2DSize,
        dynamicSMemSize: usize,
        blockSizeLimit: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuOccupancyAvailableDynamicSMemPerBlock(
        dynamicSmemSize: *mut usize,
        func: CUfunction,
        numBlocks: ::std::os::raw::c_int,
        blockSize: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefSetArray(
        hTexRef: CUtexref,
        hArray: CUarray,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefSetMipmappedArray(
        hTexRef: CUtexref,
        hMipmappedArray: CUmipmappedArray,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefSetAddress_v2(
        ByteOffset: *mut usize,
        hTexRef: CUtexref,
        dptr: CUdeviceptr,
        bytes: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefSetAddress2D_v3(
        hTexRef: CUtexref,
        desc: *const CUDA_ARRAY_DESCRIPTOR,
        dptr: CUdeviceptr,
        Pitch: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefSetFormat(
        hTexRef: CUtexref,
        fmt: CUarray_format,
        NumPackedComponents: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefSetAddressMode(
        hTexRef: CUtexref,
        dim: ::std::os::raw::c_int,
        am: CUaddress_mode,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefSetFilterMode(hTexRef: CUtexref, fm: CUfilter_mode) -> CUresult;
}
extern "C" {
    pub fn cuTexRefSetMipmapFilterMode(hTexRef: CUtexref, fm: CUfilter_mode) -> CUresult;
}
extern "C" {
    pub fn cuTexRefSetMipmapLevelBias(hTexRef: CUtexref, bias: f32) -> CUresult;
}
extern "C" {
    pub fn cuTexRefSetMipmapLevelClamp(
        hTexRef: CUtexref,
        minMipmapLevelClamp: f32,
        maxMipmapLevelClamp: f32,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefSetMaxAnisotropy(
        hTexRef: CUtexref,
        maxAniso: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefSetBorderColor(hTexRef: CUtexref, pBorderColor: *mut f32) -> CUresult;
}
extern "C" {
    pub fn cuTexRefSetFlags(hTexRef: CUtexref, Flags: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    pub fn cuTexRefGetAddress_v2(pdptr: *mut CUdeviceptr, hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    pub fn cuTexRefGetArray(phArray: *mut CUarray, hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    pub fn cuTexRefGetMipmappedArray(
        phMipmappedArray: *mut CUmipmappedArray,
        hTexRef: CUtexref,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefGetAddressMode(
        pam: *mut CUaddress_mode,
        hTexRef: CUtexref,
        dim: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefGetFilterMode(pfm: *mut CUfilter_mode, hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    pub fn cuTexRefGetFormat(
        pFormat: *mut CUarray_format,
        pNumChannels: *mut ::std::os::raw::c_int,
        hTexRef: CUtexref,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefGetMipmapFilterMode(pfm: *mut CUfilter_mode, hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    pub fn cuTexRefGetMipmapLevelBias(pbias: *mut f32, hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    pub fn cuTexRefGetMipmapLevelClamp(
        pminMipmapLevelClamp: *mut f32,
        pmaxMipmapLevelClamp: *mut f32,
        hTexRef: CUtexref,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefGetMaxAnisotropy(
        pmaxAniso: *mut ::std::os::raw::c_int,
        hTexRef: CUtexref,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefGetBorderColor(pBorderColor: *mut f32, hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    pub fn cuTexRefGetFlags(pFlags: *mut ::std::os::raw::c_uint, hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    pub fn cuTexRefCreate(pTexRef: *mut CUtexref) -> CUresult;
}
extern "C" {
    pub fn cuTexRefDestroy(hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    pub fn cuSurfRefSetArray(
        hSurfRef: CUsurfref,
        hArray: CUarray,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuSurfRefGetArray(phArray: *mut CUarray, hSurfRef: CUsurfref) -> CUresult;
}
extern "C" {
    pub fn cuTexObjectCreate(
        pTexObject: *mut CUtexObject,
        pResDesc: *const CUDA_RESOURCE_DESC,
        pTexDesc: *const CUDA_TEXTURE_DESC,
        pResViewDesc: *const CUDA_RESOURCE_VIEW_DESC,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexObjectDestroy(texObject: CUtexObject) -> CUresult;
}
extern "C" {
    pub fn cuTexObjectGetResourceDesc(
        pResDesc: *mut CUDA_RESOURCE_DESC,
        texObject: CUtexObject,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexObjectGetTextureDesc(
        pTexDesc: *mut CUDA_TEXTURE_DESC,
        texObject: CUtexObject,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexObjectGetResourceViewDesc(
        pResViewDesc: *mut CUDA_RESOURCE_VIEW_DESC,
        texObject: CUtexObject,
    ) -> CUresult;
}
extern "C" {
    pub fn cuSurfObjectCreate(
        pSurfObject: *mut CUsurfObject,
        pResDesc: *const CUDA_RESOURCE_DESC,
    ) -> CUresult;
}
extern "C" {
    pub fn cuSurfObjectDestroy(surfObject: CUsurfObject) -> CUresult;
}
extern "C" {
    pub fn cuSurfObjectGetResourceDesc(
        pResDesc: *mut CUDA_RESOURCE_DESC,
        surfObject: CUsurfObject,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDeviceCanAccessPeer(
        canAccessPeer: *mut ::std::os::raw::c_int,
        dev: CUdevice,
        peerDev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuCtxEnablePeerAccess(peerContext: CUcontext, Flags: ::std::os::raw::c_uint)
        -> CUresult;
}
extern "C" {
    pub fn cuCtxDisablePeerAccess(peerContext: CUcontext) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetP2PAttribute(
        value: *mut ::std::os::raw::c_int,
        attrib: CUdevice_P2PAttribute,
        srcDevice: CUdevice,
        dstDevice: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphicsUnregisterResource(resource: CUgraphicsResource) -> CUresult;
}
extern "C" {
    pub fn cuGraphicsSubResourceGetMappedArray(
        pArray: *mut CUarray,
        resource: CUgraphicsResource,
        arrayIndex: ::std::os::raw::c_uint,
        mipLevel: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphicsResourceGetMappedMipmappedArray(
        pMipmappedArray: *mut CUmipmappedArray,
        resource: CUgraphicsResource,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphicsResourceGetMappedPointer_v2(
        pDevPtr: *mut CUdeviceptr,
        pSize: *mut usize,
        resource: CUgraphicsResource,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphicsResourceSetMapFlags_v2(
        resource: CUgraphicsResource,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphicsMapResources(
        count: ::std::os::raw::c_uint,
        resources: *mut CUgraphicsResource,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphicsUnmapResources(
        count: ::std::os::raw::c_uint,
        resources: *mut CUgraphicsResource,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGetProcAddress(
        symbol: *const ::std::os::raw::c_char,
        pfn: *mut *mut ::std::os::raw::c_void,
        cudaVersion: ::std::os::raw::c_int,
        flags: cuuint64_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGetExportTable(
        ppExportTable: *mut *const ::std::os::raw::c_void,
        pExportTableId: *const CUuuid,
    ) -> CUresult;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUoutput_mode_enum {
    CU_OUT_KEY_VALUE_PAIR = 0,
    CU_OUT_CSV = 1,
}
pub use self::CUoutput_mode_enum as CUoutput_mode;
extern "C" {
    pub fn cuProfilerInitialize(
        configFile: *const ::std::os::raw::c_char,
        outputFile: *const ::std::os::raw::c_char,
        outputMode: CUoutput_mode,
    ) -> CUresult;
}
extern "C" {
    pub fn cuProfilerStart() -> CUresult;
}
extern "C" {
    pub fn cuProfilerStop() -> CUresult;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum cudaDataType_t {
    CUDA_R_16F = 2,
    CUDA_C_16F = 6,
    CUDA_R_16BF = 14,
    CUDA_C_16BF = 15,
    CUDA_R_32F = 0,
    CUDA_C_32F = 4,
    CUDA_R_64F = 1,
    CUDA_C_64F = 5,
    CUDA_R_4I = 16,
    CUDA_C_4I = 17,
    CUDA_R_4U = 18,
    CUDA_C_4U = 19,
    CUDA_R_8I = 3,
    CUDA_C_8I = 7,
    CUDA_R_8U = 8,
    CUDA_C_8U = 9,
    CUDA_R_16I = 20,
    CUDA_C_16I = 21,
    CUDA_R_16U = 22,
    CUDA_C_16U = 23,
    CUDA_R_32I = 10,
    CUDA_C_32I = 11,
    CUDA_R_32U = 12,
    CUDA_C_32U = 13,
    CUDA_R_64I = 24,
    CUDA_C_64I = 25,
    CUDA_R_64U = 26,
    CUDA_C_64U = 27,
}
pub use self::cudaDataType_t as cudaDataType;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum libraryPropertyType_t {
    MAJOR_VERSION = 0,
    MINOR_VERSION = 1,
    PATCH_LEVEL = 2,
}
pub use self::libraryPropertyType_t as libraryPropertyType;
